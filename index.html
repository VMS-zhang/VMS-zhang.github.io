<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/21/sizeof-strlen/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/sizeof-strlen/" class="post-title-link" itemprop="url">C语言中的strlen与sizeof的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-07-21 10:35:50 / Modified: 10:38:00" itemprop="dateCreated datePublished" datetime="2022-07-21T10:35:50+08:00">2022-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>sizeof:求数据类型所占的空间大小.<br>strlen是求字符串的长度，字符串以&#x2F;0结尾.  </p>
<p>单个长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;char=%d/n&quot;,sizeof(char));  //1</span><br><span class="line">printf(&quot;char*=%d/n&quot;,sizeof(char*)); //4</span><br><span class="line">printf(&quot;int=%d/n&quot;,sizeof(int)); //4</span><br><span class="line">printf(&quot;int*=%d/n&quot;,sizeof(int*)); //4</span><br><span class="line">printf(&quot;long=%d/n&quot;,sizeof(long)); //4</span><br><span class="line">printf(&quot;long*=%d/n&quot;,sizeof(long*)); //4</span><br><span class="line">printf(&quot;double=%d/n&quot;,sizeof(double)); //8</span><br><span class="line">printf(&quot;double*=%d/n&quot;,sizeof(double*)); //4</span><br></pre></td></tr></table></figure>

<p>数组类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *c=&quot;abcdef&quot;;</span><br><span class="line"></span><br><span class="line">char d[]=&quot;abcdef&quot;;</span><br><span class="line"></span><br><span class="line">char e[]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf(&quot;%d%d/n&quot;,sizeof(c),strlen(c)); // 4 6  </span><br><span class="line">printf(&quot;%d%d/n&quot;,sizeof(d),strlen(d)); // 7 6  </span><br><span class="line">printf(&quot;%d%d/n&quot;,sizeof(e),strlen(e)); // 6 14  </span><br></pre></td></tr></table></figure>

<p>当以字符串赋值时，”abcdef”,结尾自动加一个”&#x2F;0”.</p>
<p> strlen(c)遇到&#x2F;0就会结束，求的是字符串的长度，为6.</p>
<p> sizeof(c)求的是类型空间大小，在前面说过，指针型所点的空间大小是4个字节，系统地址总线长度为32位时。</p>
<p>strlen(d)也是一样，字符串赋值，自动添加&#x2F;0,求字符串的长度当然是6.</p>
<p>sizeof(d)是求这个数组所占空间的大小，即数组所占内存空间的字节数，应该为7.</p>
<p>sizeof(e), 数组e以单个元素赋值，没有&#x2F;0结束符，所以所占空间的大小为6个字节。</p>
<p>strlen(e),去找&#x2F;0结尾的字符串的长度，由于找不到&#x2F;0，所以返回的值是一个不确定的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/21/sizeof-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/sizeof-1/" class="post-title-link" itemprop="url">sizeof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-21 10:35:32" itemprop="dateCreated datePublished" datetime="2022-07-21T10:35:32+08:00">2022-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/21/sizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/21/sizeof/" class="post-title-link" itemprop="url">sizeof</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-21 10:35:24" itemprop="dateCreated datePublished" datetime="2022-07-21T10:35:24+08:00">2022-07-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/13/rocksdb%E5%85%B3%E9%94%AE%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/13/rocksdb%E5%85%B3%E9%94%AE%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">rocksdb关键场景</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-13 16:23:47" itemprop="dateCreated datePublished" datetime="2022-06-13T16:23:47+08:00">2022-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-15 10:14:56" itemprop="dateModified" datetime="2022-06-15T10:14:56+08:00">2022-06-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Flush-的场景"><a href="#Flush-的场景" class="headerlink" title="Flush 的场景"></a>Flush 的场景</h2><ol>
<li>Mem 的大小到达了ColumnFamilyOptions::write_buffer_size阈值  </li>
<li>所有 CF 中的 MEM 的大小到达了DBOptions::db_write_buffer_size or DBOptions::write_buffer_manager发出了 flush 的信号</li>
<li>WAL 的文件大小超过了DBOptions::max_total_wal_size，需要删除最老的 MEM，以清除 WAL。</li>
</ol>
<h2 id="Write-Batch-With-Index"><a href="#Write-Batch-With-Index" class="headerlink" title="Write Batch With Index"></a>Write Batch With Index</h2><p>index 是一个 map，映射了 key 和其在 writebatch 的 offset。<br>在读取时候，可以确定这个 WriteBatch 中是否有这个 key，如果有则根据 offset 读取，如果没有则读取 DB。</p>
<h2 id="DeleteRange-Implementation"><a href="#DeleteRange-Implementation" class="headerlink" title="DeleteRange Implementation"></a>DeleteRange Implementation</h2><p>删除的时候可能会overlap，所以需要拆分：<code>[c, d)@4, [g, h)@7, and [a, z)@10</code> into: <code>[a, c)@10, [c, d)@10, [c, d)@4, [d, g)@10, [g, h)@10, [g, h)@7, [h, z)@10</code>.   写入的是专用的mem 中，直接写入，在 read 的时候进行 split  </p>
<h2 id="读取-SST"><a href="#读取-SST" class="headerlink" title="读取 SST"></a>读取 SST</h2><p>读取 SST 的时候，使用的是TwoLevelIterator：<br>first_level_iter_：读取的是 index block<br>second_level_iter_：读取的是 data block<br><img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220614113450.png">  </p>
<h2 id="merge-Operator"><a href="#merge-Operator" class="headerlink" title="merge Operator"></a>merge Operator</h2><p><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Merge-Operator-Implementation">https://github.com/facebook/rocksdb/wiki/Merge-Operator-Implementation</a><br>主要的实现类是MergeOperator，其有两个函数FullMerge（用于实现读后写）、PartialMerge（由于实现两个 merge 类型值的合并）。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Merge Operator</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Essentially, a MergeOperator specifies the SEMANTICS of a merge, which only</span></span><br><span class="line"><span class="comment">// client knows. It could be numeric addition, list append, string</span></span><br><span class="line"><span class="comment">// concatenation, edit data structure, ... , anything.</span></span><br><span class="line"><span class="comment">// The library, on the other hand, is concerned with the exercise of this</span></span><br><span class="line"><span class="comment">// interface, at the right time (during get, iteration, compaction...)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeOperator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">MergeOperator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gives the client a way to express the read -&gt; modify -&gt; write semantics</span></span><br><span class="line">  <span class="comment">// key:         (IN) The key that&#x27;s associated with this merge operation.</span></span><br><span class="line">  <span class="comment">// existing:    (IN) null indicates that the key does not exist before this op</span></span><br><span class="line">  <span class="comment">// operand_list:(IN) the sequence of merge operations to apply, front() first.</span></span><br><span class="line">  <span class="comment">// new_value:  (OUT) Client is responsible for filling the merge result here</span></span><br><span class="line">  <span class="comment">// logger:      (IN) Client could use this to log errors during merge.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Return true on success, false on failure/corruption/etc.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">FullMerge</span><span class="params">(<span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Slice* existing_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::deque&lt;std::string&gt;&amp; operand_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::string* new_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Logger* logger)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This function performs merge(left_op, right_op)</span></span><br><span class="line">  <span class="comment">// when both the operands are themselves merge operation types.</span></span><br><span class="line">  <span class="comment">// Save the result in *new_value and return true. If it is impossible</span></span><br><span class="line">  <span class="comment">// or infeasible to combine the two operations, return false instead.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">PartialMerge</span><span class="params">(<span class="type">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> Slice&amp; left_operand,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> Slice&amp; right_operand,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::string* new_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Logger* logger)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The name of the MergeOperator. Used to check for MergeOperator</span></span><br><span class="line">  <span class="comment">// mismatches (i.e., a DB created with one MergeOperator is</span></span><br><span class="line">  <span class="comment">// accessed using a different MergeOperator)</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>get 操作的时候进行实际的 moerge 操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get</span>(key):</span><br><span class="line">  Let stack = [ ];       <span class="comment">// in reality, this should be a &quot;deque&quot;, but stack is simpler to conceptualize for this pseudocode</span></span><br><span class="line">  <span class="keyword">for</span> each entry OPi from newest to oldest:</span><br><span class="line">    <span class="keyword">if</span> OPi.type is <span class="string">&quot;merge_operand&quot;</span>:</span><br><span class="line">      <span class="function">push OPi to stack</span></span><br><span class="line"><span class="function">        <span class="title">while</span> <span class="params">(stack has at least <span class="number">2</span> elements <span class="keyword">and</span> (stack.top() <span class="keyword">and</span> stack.second_from_top() can be partial-merged)</span></span></span><br><span class="line"><span class="params"><span class="function">          OP_left = stack.pop()</span></span></span><br><span class="line"><span class="params"><span class="function">          OP_right = stack.pop()</span></span></span><br><span class="line"><span class="params"><span class="function">          result_OP = client_merge_operator.PartialMerge(OP_left, OP_right)</span></span></span><br><span class="line"><span class="params"><span class="function">          push result_OP to stack</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">else</span> <span class="keyword">if</span> OPi.type is <span class="string">&quot;put&quot;</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">return</span> client_merge_operator.FullMerge(v, stack);</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">else</span> <span class="keyword">if</span> v.type is <span class="string">&quot;delete&quot;</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">return</span> client_merge_operator.FullMerge(<span class="literal">nullptr</span>, stack);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// We&#x27;ve reached the end (OP0) and we have no Put/Delete, just interpret it as empty (like Delete would)</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> client_merge_operator.FullMerge(<span class="literal">nullptr</span>, stack);</span></span></span><br></pre></td></tr></table></figure>

<p>在 compaction 的时候，如果有 snap 引用了某一个坂本的 merge 类型的 key，则分段进行 merge：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">K:    <span class="number">0</span>    +<span class="number">1</span>    +<span class="number">2</span>    +<span class="number">3</span>    +<span class="number">4</span>     +<span class="number">5</span>      <span class="number">2</span>     +<span class="number">1</span>     +<span class="number">2</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   snapshot3</span><br><span class="line"></span><br><span class="line">We show it step by step, as we scan from the newest operation to the oldest operation</span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>    +<span class="number">1</span>    +<span class="number">2</span>    +<span class="number">3</span>    +<span class="number">4</span>     +<span class="number">5</span>      <span class="number">2</span>    (+<span class="number">1</span>     +<span class="number">2</span>)</span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              <span class="function">snapshot1   snapshot2                   snapshot3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">A Merge operation consumes a previous Merge Operation <span class="keyword">and</span> produces a <span class="keyword">new</span> Merge <span class="title">operation</span> <span class="params">(<span class="keyword">or</span> a stack)</span></span></span><br><span class="line"><span class="function">      <span class="params">(+<span class="number">1</span>  +<span class="number">2</span>)</span> </span>=&gt; <span class="built_in">PartialMerge</span>(<span class="number">1</span>,<span class="number">2</span>) =&gt; +<span class="number">3</span></span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>    +<span class="number">1</span>    +<span class="number">2</span>    +<span class="number">3</span>    +<span class="number">4</span>     +<span class="number">5</span>      <span class="number">2</span>            +<span class="number">3</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   snapshot3</span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>    +<span class="number">1</span>    +<span class="number">2</span>    +<span class="number">3</span>    +<span class="number">4</span>     +<span class="number">5</span>     (<span class="number">2</span>            +<span class="number">3</span>)</span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   snapshot3</span><br><span class="line"></span><br><span class="line">A Merge operation consumes a previous Put operation <span class="keyword">and</span> produces a <span class="keyword">new</span> Put <span class="built_in">operation</span></span><br><span class="line">      (<span class="number">2</span>   +<span class="number">3</span>) =&gt;  <span class="built_in">FullMerge</span>(<span class="number">2</span>, <span class="number">3</span>) =&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>    +<span class="number">1</span>    +<span class="number">2</span>    +<span class="number">3</span>    +<span class="number">4</span>     +<span class="number">5</span>                    <span class="number">5</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   snapshot3</span><br><span class="line"></span><br><span class="line">A newly produced Put operation is still a Put, thus hides any non-Supporting <span class="built_in">operations</span></span><br><span class="line">      (+<span class="number">5</span>   <span class="number">5</span>) =&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>    +<span class="number">1</span>    +<span class="number">2</span>   (+<span class="number">3</span>    +<span class="number">4</span>)                          <span class="number">5</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   <span class="built_in">snapshot3</span></span><br><span class="line"></span><br><span class="line">(+<span class="number">3</span>  +<span class="number">4</span>) =&gt; <span class="built_in">PartialMerge</span>(<span class="number">3</span>,<span class="number">4</span>) =&gt; +<span class="number">7</span></span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>    +<span class="number">1</span>    +<span class="number">2</span>          +<span class="number">7</span>                           <span class="number">5</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   snapshot3</span><br><span class="line"></span><br><span class="line">A Merge operation cannot consume a previous Supporting operation.</span><br><span class="line">       (+<span class="number">2</span>   +<span class="number">7</span>) can <span class="keyword">not</span> be combined</span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>   (+<span class="number">1</span>    +<span class="number">2</span>)         +<span class="number">7</span>                           <span class="number">5</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   <span class="built_in">snapshot3</span></span><br><span class="line"></span><br><span class="line">(+<span class="number">1</span>  +<span class="number">2</span>) =&gt; <span class="built_in">PartialMerge</span>(<span class="number">1</span>,<span class="number">2</span>) =&gt; +<span class="number">3</span></span><br><span class="line"></span><br><span class="line">K:    <span class="number">0</span>          +<span class="number">3</span>          +<span class="number">7</span>                           <span class="number">5</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   snapshot3</span><br><span class="line"></span><br><span class="line">K:   (<span class="number">0</span>          +<span class="number">3</span>)         +<span class="number">7</span>                           <span class="number">5</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   <span class="built_in">snapshot3</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>   +<span class="number">3</span>) =&gt; <span class="built_in">FullMerge</span>(<span class="number">0</span>,<span class="number">3</span>) =&gt; <span class="number">3</span></span><br><span class="line"></span><br><span class="line">K:               <span class="number">3</span>           +<span class="number">7</span>                           <span class="number">5</span></span><br><span class="line">                 ^           ^                            ^</span><br><span class="line">                 |           |                            |</span><br><span class="line">              snapshot1   snapshot2                   snapshot3</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Compaction</span>(snaps, files):</span><br><span class="line">  <span class="comment">// &lt;snaps&gt; is the set of snapshots (i.e.: a list of sequence numbers)</span></span><br><span class="line">  <span class="comment">// &lt;files&gt; is the set of files undergoing compaction</span></span><br><span class="line">  Let input = a file composed of the <span class="keyword">union</span> of all files</span><br><span class="line">  Let output = a file to store the resulting entries</span><br><span class="line"></span><br><span class="line">  Let stack = [];       <span class="comment">// in reality, this should be a &quot;deque&quot;, but stack is simpler to conceptualize in this pseudo-code</span></span><br><span class="line">  <span class="keyword">for</span> each v from newest to oldest in input:</span><br><span class="line">    clear_stack = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> v.sequence_number is in snaps:</span><br><span class="line">      clear_stack = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> stack <span class="keyword">not</span> empty &amp;&amp; v.key != stack.top.key:</span><br><span class="line">      clear_stack = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> clear_stack:</span><br><span class="line">      write out all operands on stack to <span class="built_in">output</span> (in the same order as encountered)</span><br><span class="line">      <span class="built_in">clear</span>(stack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v.type is <span class="string">&quot;merge_operand&quot;</span>:</span><br><span class="line">      push v to stack</span><br><span class="line">        <span class="keyword">while</span> (stack has at least <span class="number">2</span> elements <span class="built_in">and</span> (stack.top <span class="keyword">and</span> stack.second_from_top can be partial-merged)):</span><br><span class="line">          v1 = stack.<span class="built_in">pop</span>();</span><br><span class="line">          v2 = stack.<span class="built_in">pop</span>();</span><br><span class="line">          result_v = client_merge_operator.<span class="built_in">PartialMerge</span>(v1,v2)</span><br><span class="line">          push result_v to stack</span><br><span class="line">    <span class="keyword">if</span> v.type is <span class="string">&quot;put&quot;</span>:</span><br><span class="line">      write client_merge_operator.<span class="built_in">FullMerge</span>(v, stack) to output</span><br><span class="line">      clear stack</span><br><span class="line">    <span class="keyword">if</span> v.type is <span class="string">&quot;delete&quot;</span>:</span><br><span class="line">      write client_merge_operator.<span class="built_in">FullMerge</span>(<span class="literal">nullptr</span>, stack) to output</span><br><span class="line">      clear stack</span><br><span class="line"></span><br><span class="line">  If stack <span class="keyword">not</span> empty:</span><br><span class="line">    <span class="keyword">if</span> end-of-key-history <span class="keyword">for</span> key on stack:</span><br><span class="line">      write client_merge_operator.<span class="built_in">FullMerge</span>(<span class="literal">nullptr</span>, stack) to output</span><br><span class="line">      <span class="built_in">clear</span>(stack)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      write out all operands on stack to output</span><br><span class="line">      <span class="built_in">clear</span>(stack)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<h2 id="index-x2F-filter-的-partition"><a href="#index-x2F-filter-的-partition" class="headerlink" title="index&#x2F;filter 的 partition"></a>index&#x2F;filter 的 partition</h2><p><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Partitioned-Index-Filters">https://github.com/facebook/rocksdb/wiki/Partitioned-Index-Filters</a><br>对于一个 SSt 来说，可能其内部的 index or filter block 会有 MB 级别大小，这对于 block cache 是个压力。所以把 index block 进行了 partition。<br><img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220614175631.png"></p>
<p>这样在读取 index block 的时候，可以先将 top-level index 放入 cache进行读取，再决定实际读取 index block 的哪个分片。  </p>
<p>优点：</p>
<ol>
<li>提高了 cache 的命中率：更细粒度的使用 cache</li>
<li>降低 IO 压力：每次读取small size 的index数据</li>
<li>保持了 index filter 的原有性能：在不进行分区的情况下，减少索引&#x2F;过滤器内存占用的替代方法是牺牲它们的准确性，例如通过更大的数据块或更少的bloom bit来分别拥有更小的索引和过滤器。</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加了 index block 的空间：大概0.1%-1%</li>
<li>更多次 IO：如果此时 top-level index 没有在 cache 中，则需要先去读取到 cache，然后读取 partition X，有两次 IO</li>
<li>局部性降低：如果随机大量读某个 SST，那样可能会进行多次 IO 读取多个 partition 的 index block，还不如直接读取整个的 index block</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/13/rocksdb%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/13/rocksdb%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">rocksdb参数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-13 16:11:52" itemprop="dateCreated datePublished" datetime="2022-06-13T16:11:52+08:00">2022-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-23 17:54:25" itemprop="dateModified" datetime="2022-06-23T17:54:25+08:00">2022-06-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>enable_pipelined_write<br><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Pipelined-Write">https://github.com/facebook/rocksdb/wiki/Pipelined-Write</a><br>在 LevelDB 中 先写 WAL 然后写 Mem Table，二者是串行的。RocksDB 开启此参数之后，前一个 WAL 写完之后，后一个的 WAL 可以立刻写 WAL，而前一个可以去并行的去写 MEM。</p>
</li>
<li><p>write_buffer_size<br>Mem 的大小</p>
</li>
<li><p>db_write_buffer_size<br><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/MemTable">https://github.com/facebook/rocksdb/wiki/MemTable</a><br>整个 DB 中 Mem 的总大小，包括所有的 cf。</p>
</li>
<li><p>max_write_buffer_number<br>内存中同时存在的最多的 Mem 的个数。</p>
</li>
<li><p>max_write_buffer_size_to_maintain<br>在内存中保存的MEMs数据大小的阈值。</p>
</li>
<li><p>–rate_limiter_bytes_per_sec<br>Set options.rate_limiter value,限制flush和compaction的速度。</p>
</li>
<li><p>–num</p>
</li>
<li><p>–num_levels<br>The total number of levels</p>
</li>
<li><p>–key_size</p>
</li>
<li><p>–value_size</p>
</li>
<li><p>–block_size<br>Number of bytes in a block.</p>
</li>
<li><p>–cache_numshardbits<br>cache分片时候是用的，2^cache_numshardbits个小cache</p>
</li>
<li><p>–compression_max_dict_bytes</p>
</li>
<li><p>–compression_ratio</p>
</li>
<li><p>–level_compaction_dynamic_level_bytes<br>Whether level size base is dynamic</p>
</li>
<li><p>–bytes_per_sync<br>Allows OS to incrementally sync SST files to disk while they are being written, in the background. Issue one request for every bytes_per_sync written. 0 turns it off.</p>
</li>
<li><p>–cache_index_and_filter_blocks<br>Cache index&#x2F;filter blocks in block cache.</p>
</li>
<li><p>–pin_l0_filter_and_index_blocks_in_cache<br>Pin index&#x2F;filter blocks of L0 files in block cache.</p>
</li>
<li><p>–benchmark_write_rate_limit<br>If non-zero, db_bench will rate-limit the writes going into RocksDB. This is the global rate in bytes&#x2F;second.</p>
</li>
<li><p>–hard_rate_limit</p>
</li>
<li><p>–rate_limit_delay_max_milliseconds</p>
</li>
<li><p>–write_buffer_size<br>memtable的大小</p>
</li>
<li><p>–max_write_buffer_number<br>内存中Table的最大个数</p>
</li>
<li><p>–target_file_size_base<br>第一层的文件大小，配合target_file_size_multiplier使用，第一层的文件大小如果是10mb，target_file_size_multiplier&#x3D;4的话，那么第二层的每个文件的大小是10<em>4&#x3D;40mb，第三层是10</em>4*4&#x3D;160mb….</p>
</li>
<li><p>–max_bytes_for_level_base<br>第一层的最大byte的数量，即Level-one的最大大小</p>
</li>
<li><p>–verify_checksum</p>
</li>
<li><p>–delete_obsolete_files_period_micros</p>
</li>
<li><p>–max_bytes_for_level_multiplier<br>相邻层之间的放大系数</p>
</li>
<li><p>–statistics</p>
</li>
<li><p>–stats_per_interval<br>Reports additional stats per interval when this is greater than 0</p>
</li>
<li><p>–stats_interval_seconds<br>Report stats every N seconds. This overrides stats_interval when both are &gt; 0.</p>
</li>
<li><p>–histogram</p>
</li>
<li><p>–memtablerep</p>
</li>
<li><p>–bloom_bits</p>
</li>
<li><p>–open_files<br>Maximum number of files to keep open at the same time (use default if &#x3D;&#x3D; 0)) type: int32 default: -1</p>
</li>
<li><p>–duration<br>Time in seconds for the random-ops tests to run. When 0 then num &amp; reads determine the test duration</p>
</li>
<li><p>–level0_file_num_compaction_trigger<br>L0触发compaction的文件数阈值</p>
</li>
<li><p>–level0_slowdown_writes_trigger<br>L0文件数达到这个数值时候，导致write慢下来</p>
</li>
<li><p>–level0_stop_writes_trigger<br>L0文件数达到这个数值时候，导致write被阻塞，等待flush</p>
</li>
<li><p>–max_background_jobs</p>
</li>
<li><p>–batch_size<br>每个batch可以放多条KV，这个参数指定batch可以放的个数</p>
</li>
<li><p>–mmap_read</p>
</li>
<li><p>–cache_size</p>
</li>
<li><p>–delayed_write_rate</p>
</li>
<li><p>–max_total_wal_size</p>
</li>
<li><p>–prepare_log_writer_num</p>
</li>
<li><p>–new_table_reader_for_compaction_inputs</p>
</li>
<li><p>–max_background_compactions</p>
</li>
<li><p>–max_background_flushes</p>
</li>
<li><p>–table_cache_numshardbits</p>
</li>
<li><p>–max_wal_size</p>
</li>
<li><p>–dump_malloc_stats</p>
</li>
<li><p>–stats_dump_period_sec</p>
</li>
<li><p>–use_direct_reads</p>
</li>
<li><p>–wal_bytes_per_sync</p>
</li>
<li><p>–perf_level</p>
</li>
<li><p>–target_blob_file_size</p>
</li>
<li><p>–blob_size</p>
</li>
<li><p>–blob_large_key_ratio</p>
</li>
<li><p>–blob_file_defragment_size</p>
</li>
<li><p>–blob_gc_ratio</p>
</li>
<li><p>–max_dependence_blob_overlap</p>
</li>
<li><p>–hard_pending_compaction_bytes_limit</p>
</li>
<li><p>–max_compaction_bytes</p>
</li>
<li><p>–enable_lazy_compaction</p>
</li>
<li><p>–optimize_filters_for_hits</p>
</li>
<li><p>–soft_pending_compaction_bytes_limit</p>
</li>
<li><p>–pin_top_level_index_and_filter</p>
</li>
<li><p>–threads</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/09/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">linux 常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-09 09:53:46" itemprop="dateCreated datePublished" datetime="2022-06-09T09:53:46+08:00">2022-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-21 17:41:01" itemprop="dateModified" datetime="2022-06-21T17:41:01+08:00">2022-06-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>使用 alias 设置别名<br>系统环境变量一般保存在下面的文件中：</li>
</ol>
<ul>
<li><code>~/bash_profile</code>: 若bash是以login方式执行时，读取<code>~/.bash_profile</code>，若它不存在,则读取<code>~/.bash_login</code>，若前两者不存在，读取<code>~/.profile</code>。</li>
</ul>
<p>我个人自己的电脑一般在<code>bash_profile</code>下面设置 alias。</p>
<ol start="2">
<li><p>查看当前文件夹挂载目录名：<code>df -h .</code></p>
</li>
<li><p>时间倒序查看文件<code>ls -lrht filenames</code>.  reverse、human、time</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/24/docker%E4%B8%8B%E7%9A%84mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/24/docker%E4%B8%8B%E7%9A%84mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">docker下的mysql主从同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-24 21:33:14 / Modified: 21:55:02" itemprop="dateCreated datePublished" datetime="2022-05-24T21:33:14+08:00">2022-05-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol>
<li>安装mysql 的 docker 镜像<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure></li>
<li>run docker 镜像     </li>
<li>运行 mysql</li>
<li>配置 master</li>
</ol>
<ul>
<li>配置&#x2F;etc&#x2F;mysql&#x2F;my.cnf（配置完之后重启下 mysql）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sql_mode<span class="operator">=</span>STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line">#gtid:</span><br><span class="line">server_id <span class="operator">=</span> <span class="number">1</span>                   #服务器id</span><br><span class="line">gtid_mode <span class="operator">=</span> <span class="keyword">on</span>                  #开启gtid模式</span><br><span class="line">enforce_gtid_consistency <span class="operator">=</span> <span class="keyword">on</span>   #强制gtid一致性，开启后对于特定<span class="keyword">create</span> <span class="keyword">table</span>不被支持</span><br><span class="line"></span><br><span class="line">#binlog</span><br><span class="line">log_bin <span class="operator">=</span> mysql<span class="operator">-</span>binlog</span><br><span class="line">log_slave_updates <span class="operator">=</span> <span class="keyword">on</span>    </span><br><span class="line">binlog_format <span class="operator">=</span> <span class="type">row</span>             #强烈建议，其他格式可能造成数据不一致</span><br><span class="line"></span><br><span class="line">#relay log</span><br><span class="line">skip_slave_start <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">default_authentication_plugin <span class="operator">=</span> <span class="string">&#x27;mysql_native_password&#x27;</span>  #更改加密方式</span><br></pre></td></tr></table></figure>

<ul>
<li>在 master 上创建鉴权用户（未来slave使用这个用户进行连接）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 创建用户 repli 密码为 <span class="number">123456</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;repli&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">WITH</span> <span class="string">&#x27;mysql_native_password&#x27;</span> <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">## 赋予用户 repli 权限</span><br><span class="line">$ <span class="keyword">grant</span> replication slave,replication client <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;repli&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">## 刷新权限</span><br><span class="line">$ flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>配置 slave</li>
</ol>
<ul>
<li>配置&#x2F;etc&#x2F;mysql&#x2F;my.cnf</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sql_mode<span class="operator">=</span>STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line"></span><br><span class="line">#GTID:</span><br><span class="line">server_id <span class="operator">=</span> <span class="number">2</span>                  #服务器id</span><br><span class="line">gtid_mode <span class="operator">=</span> <span class="keyword">on</span>                 #开启gtid模式</span><br><span class="line">enforce_gtid_consistency <span class="operator">=</span> <span class="keyword">on</span>  #强制gtid一致性，开启后对于特定<span class="keyword">create</span> <span class="keyword">table</span>不被支持</span><br><span class="line"></span><br><span class="line">#binlog</span><br><span class="line">log_bin <span class="operator">=</span> mysql<span class="operator">-</span>binlog</span><br><span class="line">log_slave_updates <span class="operator">=</span> <span class="keyword">on</span>   </span><br><span class="line">binlog_format <span class="operator">=</span> <span class="type">row</span>            #强烈建议，其他格式可能造成数据不一致</span><br><span class="line"></span><br><span class="line">#relay log</span><br><span class="line">skip_slave_start <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">default_authentication_plugin <span class="operator">=</span> <span class="string">&#x27;mysql_native_password&#x27;</span>  #更改加密方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>连接主节点</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">     master_host<span class="operator">=</span><span class="string">&#x27;XXX&#x27;</span>,</span><br><span class="line">     master_port<span class="operator">=</span><span class="number">3306</span>,</span><br><span class="line">     master_user<span class="operator">=</span><span class="string">&#x27;repli&#x27;</span>,</span><br><span class="line">     master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">     master_auto_position<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>master的 ip 地址的查看方式：<br><code>docker inspect mysql-master</code>,此处我的 master 镜像的name 为mysql-master。</p>
<ol start="6">
<li>开启</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看连接状态：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.2.11</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-binlog.000003</span><br><span class="line">          Read_Master_Log_Pos: 886</span><br><span class="line">               Relay_Log_File: node-02-relay-bin.000003</span><br><span class="line">                Relay_Log_Pos: 1107</span><br><span class="line">        Relay_Master_Log_File: mysql-binlog.000003</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 886</span><br><span class="line">              Relay_Log_Space: 3129553</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File:</span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File:</span><br><span class="line">           Master_SSL_CA_Path:</span><br><span class="line">              Master_SSL_Cert:</span><br><span class="line">            Master_SSL_Cipher:</span><br><span class="line">               Master_SSL_Key:</span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error:</span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error:</span><br><span class="line">  Replicate_Ignore_Server_Ids:</span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: f5c69d56-694c-11eb-800e-000c29e6fc4e</span><br><span class="line">             Master_Info_File: mysql.slave_master_info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind:</span><br><span class="line">      Last_IO_Error_Timestamp:</span><br><span class="line">     Last_SQL_Error_Timestamp:</span><br><span class="line">               Master_SSL_Crl:</span><br><span class="line">           Master_SSL_Crlpath:</span><br><span class="line">           Retrieved_Gtid_Set: f5c69d56-694c-11eb-800e-000c29e6fc4e:1-8</span><br><span class="line">            Executed_Gtid_Set: 13f0092c-694d-11eb-aba6-000c29262359:1-5,</span><br><span class="line">f5c69d56-694c-11eb-800e-000c29e6fc4e:1-8</span><br><span class="line">                Auto_Position: 1</span><br><span class="line">         Replicate_Rewrite_DB:</span><br><span class="line">                 Channel_Name:</span><br><span class="line">           Master_TLS_Version:</span><br><span class="line">       Master_public_key_path:</span><br><span class="line">        Get_master_public_key: 0</span><br><span class="line">            Network_Namespace:</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li>在 master 节点创建数据库表:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">##创建名为 test 的数据库</span><br><span class="line">$ CREATE DATABASE test;</span><br><span class="line"></span><br><span class="line">##使用 test 数据库</span><br><span class="line">$ USE test;</span><br><span class="line"></span><br><span class="line">##创建 user 表</span><br><span class="line">$ CREATE TABLE `user`  (</span><br><span class="line">  `id` int(0) NOT NULL,</span><br><span class="line">  `name` varchar(20) NULL DEFAULT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">##插入测试数据</span><br><span class="line">$ INSERT INTO `user` VALUES (1, &#x27;mydlq&#x27;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看从库是否同步过来</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">##查看全部数据库</span><br><span class="line">$ SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line"></span><br><span class="line">##使用 test 数据库</span><br><span class="line">$ USE test;</span><br><span class="line"></span><br><span class="line">##查看全部表</span><br><span class="line">$ SHOW TABLES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">+--------------------+</span><br><span class="line"></span><br><span class="line">## 查看 user 表中数据</span><br><span class="line">$ SELECT * FROM `user`;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | name  |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 | mydlq |</span><br><span class="line">+----+-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a target="_blank" rel="noopener" href="http://www.mydlq.club/article/106/">http://www.mydlq.club/article/106/</a><br><a target="_blank" rel="noopener" href="https://www.modb.pro/db/29919">https://www.modb.pro/db/29919</a>  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/silk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/16/silk/" class="post-title-link" itemprop="url">silk</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-16 11:30:01" itemprop="dateCreated datePublished" datetime="2022-05-16T11:30:01+08:00">2022-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-18 11:43:02" itemprop="dateModified" datetime="2022-05-18T11:43:02+08:00">2022-05-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol start="2">
<li>LSM KVs exhibit high tail latencies.  Tail latency is especially important, because applications often exhibit high fan-out queries whose overall latency is determined by the response time of the slowest reply.<br>Internal operations remain necessary, and client operations that arrive during ongoing internal operations experience increased latency because of interference with these internal tasks.</li>
</ol>
<ul>
<li>The root cause of these high tail latencies is interference between client writes, flushes and compactions.</li>
<li>We then introduce the notion of an I&#x2F;O scheduler for an LSM-based KV store to reduce this interference.</li>
</ul>
<p>We explore three techniques as part of this I&#x2F;O scheduler: 1) opportunistically allocating more bandwidth to internal operations during periods of low load, 2) prioritizing flushes and compactions at the lower levels of the tree, and 3) preempting compactions.</p>
<p>planA：<br>One may at first think that limiting the I&#x2F;O bandwidth allocated to internal operations.</p>
<ol>
<li>consider a burst of client writes, triggering a burst of flushes. If a number of compactions is going on at the same time, the flushes have to share the limited bandwidth with the compactions, and they become slow. This leads to the in-memory component filling up and blocking further writes, hence producing latency spikes.</li>
</ol>
<p>planB:<br>Limiting the rate of compactions.</p>
<ol>
<li>they can lead to the lowest level of the tree filling up, stalling flushes, and in turn stalling writes.</li>
</ol>
<p>PlanC:</p>
<ol>
<li>introduce an I&#x2F;O scheduler for an LSM-based KV store.</li>
</ol>
<p>(1) dynamically allocates bandwidth between client and internal operations, (2) gives preference to internal operations that may block client operations, and (3) allows preemption of less critical internal operations.</p>
<p><img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220516124746.png"></p>
<p>Figure 2 illustrates an example of a write latency spike (the red dashed line) occurring because L0 reaches maximum capacity (10 SSTables in this example). Several compactions on levels L0, L1 and L2 occur in parallel between t &#x3D; 14 and t &#x3D; 23. Even if many parallel compactions can run at higher levels (i.e., Li to Li+1, where i &gt;0), there can only be one L0 to L1 compaction running at a time. Since I&#x2F;O bandwidth is spread equally over all compactions, L0 to L1 compaction is slowed down. Consequently, L0 is not cleared fast enough, which, in turn, causes flushes from Cm to be temporarily halted.</p>
<p><img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220516124904.png"><br>A second cause for latency spikes is Cm filling up because of slow flushing, as illustrated in Figure 3. Here, L0 does not fill up, reaching only 7 SSTables at t &#x3D; 5. However, the flush starting at t &#x3D; 0 takes an unusually long time (5 seconds compared to 1-2 seconds for a typical flush). The cause is that, by coincidence, a large number of compactions are running at the same time, which makes flushing slow because of limited available I&#x2F;O bandwidth. There are 7 ongoing compactions at the time of the very slow flush.</p>
<p>Conclusion<br>Lesson 1) The main reason for high tail latency is the fact that writes get blocked by Cm filling up. There are two principal reasons for this. The first reason is that L0 on disk is full, which causes flushes from Cm to be halted. L0 reaches its capacity if L0 to L1 compaction cannot keep up. The second reason is that, by coincidence, a large number of compactions are happening concurrently, which causes flushing to be slow because of limited available bandwidth.<br>&#x3D;&#x3D;&gt; As a corollary to Lesson 1, we conclude that not all internal operations are equal. Internal operations on the lower levels of the tree (i.e., closer to Cm) are critical, because failing to complete them in a timely fashion may result in stalling client operations.<br>Lesson 2) Simply limiting bandwidth for internal operations does not solve the problem of limited bandwidth being available for flushes and can in fact exacerbate it in the long run. This approach effectively postpones compactions, and therefore increases the likelihood that at some later point many compactions occur at the same time.  </p>
<p> design principal</p>
<ol>
<li>opportunistically allocating I&#x2F;O bandwidth to internal operations.<br> SILK allocates less I&#x2F;O bandwidth to compactions on higher levels during peak client load, and exploits transient low-load periods to boost the processing of internal operations.</li>
</ol>
<p>(1) to limit interference between internal operations and client-facing ones, and (2) to avoid accumulating over time too large a backlog of internal work, preventing overload conditions in the long term.</p>
<ol start="2">
<li><p>Prioritizing internal operations at the lower levels of the tree.<br> (1) SILK ensures that the flushes are fast, making room in memory to absorb incoming updates, which directly affects write latency, (2) SILK gives second priority to L0 to L1 compactions, ensuring that L0 does not reach its full capacity, so that flushes can proceed, (3) SILK gives third priority to compactions on the levels below L1 because, while they maintain the structure of the LSM tree, their timely execution does not significantly affect client operation latencies in the short term.</p>
</li>
<li><p>Preempting compactions.<br> allows internal operations on lower levels of the tree to preempt compactions on higher levels.</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/03/c-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">c++构造函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-03 18:24:47" itemprop="dateCreated datePublished" datetime="2022-05-03T18:24:47+08:00">2022-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-05 20:29:13" itemprop="dateModified" datetime="2022-05-05T20:29:13+08:00">2022-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++中，类通过一个或者几个特殊的成员函数来控制类的初始化过程，这些函数就是构造函数。构造函数的任务是初始化类的<strong>数据成员</strong>。</p>
<blockquote>
<p>构造函数特征</p>
</blockquote>
<ol>
<li>构造函数的名字和类名相同</li>
<li>构造函数没有返回类型</li>
<li>同一个类的（如果有）多个构造函数类似普通函数的重载，需要在参数类型 or 参数数量上有所区别</li>
<li>类的构造函数不能被声明为 const（类的成员函数是可以的）。因为构造函数需要初始化类的数据成员，这个过程会改变类数据成员的值，即使类的数据成员是 const 的，这个 const 属性也只有在完成构造的时候才具有“常量”属性。</li>
</ol>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>即使当前类没有定义任何的构造函数，程序依然是可以运行的，因为编译器会自动生成默认的构造函数。<br>默认构造函数的形式一般是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span> ()&#123;&#125;  <span class="comment">// 默认构造函数没有任何的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>默认构造函数的初始化规则是：</p>
<ol>
<li>如果类内存在初始值，则用初始值来初始化数据成员</li>
<li>否则，按照默认初始化来初始化数据成员：定义于函数体内的内置类型如果没有初始化，则其值未定义；数据成员如果是类的对象，则按照类的默认构造函数进行初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">// 1.如果类内存在初始值，则用初始值来初始化数据成员</span></span><br><span class="line">    <span class="type">int</span> b; <span class="comment">// 2.按照默认初始化来初始化数据成员，int 执行默认初始化的时候其值未定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A:a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; ,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a;</span><br><span class="line">    string s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">print</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;s=&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output：</span></span><br><span class="line"><span class="comment">A:a=0 ,b=1  // b 的值未定义，初值不确定</span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">A:a=0 ,b=1</span></span><br><span class="line"><span class="comment">s=</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面的程序，类 A 没有显式定义默认构造函数，程序自动生成默认构造函数：按照规则1因为a 已经有了初始值 0，那么a 最终的值为 0；因为 b 没有显式设置初始值，那么其实际的值未定义。<br>类 B 的数据成员 A a 因为 类 A 有编译器自动生成的默认构造函数，那么a 按照默认构造进行初始化；s 按照 string 类的默认构造函数进行初始化，默认为””；</p>
<blockquote>
<p>默认构造函数只有在没有显式定义构造函数，那么才会自动生成默认构造函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A:a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; ,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式定义了构造函数，那么不会隐式的生成默认构造函数了</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a1, <span class="type">int</span> b1) : <span class="built_in">a</span>(a1), <span class="built_in">b</span>(b1) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;<span class="comment">// 编译失败，因为显式定义了一个构造函数，无法生成默认构造函数。</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 调用的是 A(int a1, int b1)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成默认构造函数的前提：</p>
</blockquote>
<ol>
<li>类中含有其他类型T的数据成员，且这个T有自己的默认构造函数（不论是显式定义的 or 隐式定义的）</li>
<li>如果默认构造函数被标记为<code>=delete</code>（具体内容见下文），那么也不会自动生成构造函数。</li>
</ol>
<hr>
<p>此时类 B是无法隐式自动生成的默认构造函数的，因为其数据成员 A a定义了显式的构造函数，无法生成默认构造函数。如果想要得到 B 的对象，必须显式提供B 的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">private:</span><br><span class="line">    A a;</span><br><span class="line">    string s;</span><br><span class="line">public:</span><br><span class="line">    void print() &#123;</span><br><span class="line">        a.print();</span><br><span class="line">        cout &lt;&lt; &quot;s=&quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    B(A a, string s2 = &quot;&quot;) : a(a), s(s2) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>对于规则 2，其基本格式如下：<code>A() = delete;</code>，这样类 A 就不能自动生成默认构造函数了。delete 详见下文。</p>
<h2 id="函数初始化列表"><a href="#函数初始化列表" class="headerlink" title="函数初始化列表"></a>函数初始化列表</h2><p>函数初始化列表就是刚才看到的<code>B(A a, string s2 = &quot;&quot;) : a(a), s(s2) &#123;&#125;</code>形式。<code>a(a), s(s2)</code>不是在函数体内进行初始化，而是在函数体外进行的。</p>
<blockquote>
<p>没有出现在构造函数初始化列表里的数据成员将通过相应类型的类内初始值初始化或者执行默认初始化，而在初始化列表里的数据成员则是按照给定值进行初始化的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a; <span class="comment">// 必须使用初始化列表进行初始化</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> a2) : <span class="built_in">a</span>(a) &#123;</span><br><span class="line">        <span class="comment">// 此时 b 已经使用默认初始化的方式进行初始化了</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 a 来说，必须在列表中进行初始化，否则在进入函数体的时候，类的数据成员都按照默认初始化的方式进行初始化，无法对 const 类型的 a 进行赋值了。</p>
<h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>对象发生拷贝的情况一般是初始化变量以及以值的方式传递或者返回一个对象等情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">fun</span><span class="params">(A a)</span></span>&#123; <span class="comment">// 参数 a 调用了拷贝构造函数</span></span><br><span class="line">    A c;</span><br><span class="line">    <span class="keyword">return</span> c;<span class="comment">// 以值得形式返回，调用拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line">A b; <span class="comment">// 默认构造函数</span></span><br><span class="line">A a = b; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="built_in">fun</span>(a); <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<p>拷贝构造函数的形式一般是：</p>
<ol>
<li>构造函数的第一个参数是自身引用类型</li>
<li>如果后面有其余参数的话，每个参数都有默认值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D &amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li>与构造函数类似，如果没有定义拷贝构造函数，编译器会自动构造一个。但是和默认构造函数不同的是，即使已经定义了其他构造函数，编译器也会自动生成一个拷贝构造函数，除非我们使用 delete 来命令编译器不要生成该函数！  </li>
<li>自动合成的拷贝构造函数的行为和自动生成的默认构造函数相同，会将被复制对象的数据成员逐个复制到新生成的对象上去。</li>
</ol>
<ul>
<li>对于类成员，那么按照类的拷贝构造函数</li>
<li>对于内置类型的数据成员，则直接拷贝值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 自动生成拷贝构造、默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    A a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>(); <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有定义那么自动生成的构造函数可以理解为是这个样子</span></span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D &amp;D1) : <span class="built_in">d</span>(D1.d), <span class="built_in">a</span>(D1.a) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>拷贝构造函数是在生成对象时候用的，注意<strong>构造</strong>两个字！而接下来的拷贝赋值函数是在给已存在的对象进行赋值时候使用的。</li>
</ol>
<blockquote>
<p>！！第一个参数必须是引用类型 &amp; 应该为 const 标识</p>
</blockquote>
<p>拷贝构造函数被用来初始化非引用类类型参数，如果其参数不是引用类型，那么调用会永远递归下去：为了调用拷贝构造函数，必须拷贝他的实参，为了拷贝实参，有需要调用拷贝构造函数。<br>在 clion 上试了一下，现在编译器已经可以自动识别出这个错误来了：<br><img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220504212149.png"></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8436467/why-is-copy-constructor-not-allowed-pass-by-value">Why should the copy constructor accept its parameter by reference in C++?</a>    </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tunsanty/article/details/4264738">实在不理解，运行一下才行这个例子调试一下看看</a>:  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CExample</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_nTest;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CExample</span>(<span class="type">int</span> x):<span class="built_in">m_nTest</span>(x) <span class="comment">//带参数构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">	   cout &lt;&lt; <span class="string">&quot;constructor with argument/n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CExample</span>(<span class="type">const</span> CExample &amp; ex) <span class="comment">//拷贝构造函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_nTest = ex.m_nTest;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy constructor/n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CExample&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CExample &amp;ex)<span class="comment">//赋值函数(赋值运算符重载)</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;assignment operator/n&quot;</span>;</span><br><span class="line">		m_nTest = ex.m_nTest;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">myTestFunc</span><span class="params">(CExample ex)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CExample <span class="title">aaa</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">CExample <span class="title">bbb</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	bbb = aaa;</span><br><span class="line">	CExample ccc = aaa;</span><br><span class="line">	bbb.<span class="built_in">myTestFunc</span>(aaa);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="拷贝构造函数被调用的情况"><a href="#拷贝构造函数被调用的情况" class="headerlink" title="拷贝构造函数被调用的情况"></a>拷贝构造函数被调用的情况</h2><ol>
<li>使用&#x3D;对一个新对象进行初始化的时候</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。</span></span><br><span class="line"><span class="comment">//下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。</span></span><br><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br><span class="line">Complex c2 = c1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complex c3;</span><br><span class="line">c3 = c2;   <span class="comment">// 是拷贝赋值，因为 c3 已经存在</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将对象作为一个实参传递给一个非引用类型的实参</li>
<li>将一个非引用类型的对象返回</li>
<li>使用花括号列表初始化一个数组中的元素<code>string str[2]&#123;&quot;lll&quot;,&quot;ttt&quot;&#125;;</code> or 一个聚合类中的成员</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;t) : <span class="built_in">a</span>(t.a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用了拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;现在是 func 的内部&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// 调用拷贝构造来复制返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;<span class="comment">// 默认构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用 func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment">        调用 func</span></span><br><span class="line"><span class="comment">        调用了拷贝构造函数</span></span><br><span class="line"><span class="comment">        现在是 func 的内部</span></span><br><span class="line"><span class="comment">        调用了拷贝构造函数</span></span><br><span class="line"><span class="comment">        调用结束</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>另外，某些类类型还会对他们分配的对象进行拷贝初始化：当在容器例如vector 上调用 insert or emplace的时候；此内容可以查看相关博客。</p>
<h1 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h1><p>与构造函数一样吗，如果没有定义拷贝赋值函数，编译器会自动合成。<br>工作模式是将右侧的对象的每个非 static 数据成员依次使用成员类型的拷贝赋值函数来实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 内置数据成员，执行拷贝赋值时候直接赋值</span></span><br><span class="line">    B b;<span class="comment">// 类数据成员，执行 B 类的拷贝赋值函数进行赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拷贝运算符的格式如下：</p>
<ol>
<li>参数类型和本类相同</li>
<li>参数通常使用 const标志符</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/bama2488313716/article/details/46545013">返回运算符左侧的引用</a></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 内置数据成员，执行拷贝赋值时候直接赋值</span></span><br><span class="line"><span class="comment">//    B b;// 类数据成员，执行 B 类的拷贝赋值函数进行赋值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a1) : <span class="built_in">a</span>(a1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;t) : <span class="built_in">a</span>(t.a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用拷贝赋值函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        a = t.a;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    a2 = a1;</span><br><span class="line">    a1.<span class="built_in">print</span>();</span><br><span class="line">    a2.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">默认构造函数</span><br><span class="line">默认构造函数</span><br><span class="line">调用拷贝赋值函数</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>


<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>构造函数的目的是生成一个对象，析构函数的目的是销毁一个对象并回收对象申请而资源（如果有的话）。</p>
<p>格式：</p>
<ol>
<li>不接受参数</li>
<li>名字和类名相同，但是多一个<code>~</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 内置数据成员，执行拷贝赋值时候直接赋值</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a1) : <span class="built_in">a</span>(a1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[a1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] p; <span class="comment">// 对象拥有在堆上分配的资源，所以在销毁对象时候必须释放掉！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * output:</span></span><br><span class="line"><span class="comment">     * 默认构造函数</span></span><br><span class="line"><span class="comment">     * 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上析构函数本身不直接销毁成员，而是<strong>在析构函数之后隐藏的析构阶段被销毁</strong>。在整个对象的析构过程中，析构函数体是作为成员销毁步骤之外的另一部分。</p>
<blockquote>
<p>调用析构函数的时机</p>
</blockquote>
<ol>
<li>变量离开作用域的时候</li>
<li>一个对象被销毁时候，如果其内部拥有类类型的数据成员，则该成员也会调用其自身的析构函数进行销毁。</li>
<li>容器被销毁的时候，其内部的元素被销毁</li>
<li>动态分配的对象，对其进行 delete 的时候</li>
<li>临时对象完整的表达式结束的时候</li>
</ol>
<blockquote>
<p>大多数时候应该定义默认构造函数、拷贝构造函数、拷贝赋值函数，不论是显式的还是隐式的。</p>
</blockquote>
<h1 id="default"><a href="#default" class="headerlink" title="default"></a>default</h1><p>在c++11 新标准中，如果想要默认的行为，那么可以在函数的参数列表后面写上<code>=default</code>来要求编译器生成默认构造函数（即使已经定义了其他的构造函数）。  </p>
<ul>
<li>只能对编译器可以合成的 <strong>默认构造函数、拷贝控制成员使用&#x3D;default。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝控制成员：</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 显式定义了构造函数，那么不会隐式的生成默认构造函数了</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a1, <span class="type">int</span> b1) : <span class="built_in">a</span>(a1), <span class="built_in">b</span>(b1) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果想要使用默认行为初始化 A，则需要指名 default</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;<span class="comment">// 正确</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>default既可以声明在类的内部，也可以声明在外部。在内部声明的话，则默认构造函数是内联的；如果声明在外部，默认不是内联的。</p>
</blockquote>
<blockquote>
<p>因为使用 default 声明之后，函数使用的是默认情况进行初始化类对象的，所以函数不接受任何参数，否则编译器不知道参数任何匹配导致失败。</p>
</blockquote>
<h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p>被 delete 标记的函数代表：虽然声明了这些函数，但是不能以任何形式使用这些函数。</p>
<ul>
<li>在函数列表之后加上&#x3D;delete 代表它是被删除的。</li>
<li>可以对任何函数指定&#x3D;delete</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">// 内置数据成员，执行拷贝赋值时候直接赋值</span></span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不准使用默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> t) : <span class="built_in">a</span>(t) &#123; p = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1; <span class="comment">//编译不通过：Call to deleted constructor of &#x27;A&#x27;</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/02/c-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/02/c-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/" class="post-title-link" itemprop="url">c++自动类型推断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-02 23:28:53" itemprop="dateCreated datePublished" datetime="2022-05-02T23:28:53+08:00">2022-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-03 00:39:24" itemprop="dateModified" datetime="2022-05-03T00:39:24+08:00">2022-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index"><span itemprop="name">cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>c++11 提供了两种自动类型推断的方式：</p>
<ol>
<li>auto</li>
<li>decltype</li>
</ol>
<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>auto让编译器去分析表达式的类型，与原来的特定的类型说明符（例如 double）不同的是，auto 通过让编译器使用初始值来推算变量的类型。所以：<strong>auto定义的变量必须有初始值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b; <span class="comment">// c初始化为 a和 b 相加的结果</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果 a 和 b 是 int 的对象，那 c 的类型就是 int</li>
<li>如果 a 和 b 是 class A 的对象，那么 c 的类型就是 class A</li>
</ul>
<ol>
<li><p>auto 可以一次性生命多个变量，但是多个变量的类型必须相同。<br><img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220502233643.png"><br>自动推断出了 c 的类型是 A，d 的类型是 A*。</p>
</li>
<li><p>编译器推断出来的 auto 类型有时候可能和初始值的类型不一样</p>
</li>
</ol>
<ul>
<li>在使用引用的时候实际使用的是引用的对象，特别是当引用被用作初始值的时候，<strong>真正参与初始化的其实是引用对象的值</strong>。<br>此时编译器自动以引用对象的类型作为 auto 的类型：<br><img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220502234131.png"></li>
</ul>
<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>decltpye:想要使用表达式的类型推断出来定义的变量的类型，而又不想使用该表达式的类型的值来初始化变量；其主要作用是返回操作数的数据类型，在此过程中，编译器分析表达式并得到他的类型，但不实际计算其值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x的类型就是 f()的返回类型</span></span><br><span class="line"><span class="comment">// 编译器没有执行 f，而是使用调用发生时f 的返回值类型作为 x 的类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) x = a;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.如果 decltype 使用的表达式是一个<strong>变量</strong>，那么 decltype 返回该变量的类型（包括 const 和引用）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x 类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) x = a;</span><br><span class="line"><span class="comment">// y 类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">g</span>()) y = a;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.如果 decltype 使用的表达式不是一个变量，那么返回表达式结果对应的类型</p>
</blockquote>
<ul>
<li>如果表达式的求值结果是左值，那么 decltpye作用于该表达式（不是变量）得到一个引用类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// r+0是一个右值，类型是 int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i; <span class="comment">// *p可以被赋值，所以是一个左值,int&amp;</span></span><br></pre></td></tr></table></figure>
<img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220503001255.png"></li>
</ul>
<blockquote>
<p>3.对于 decltype 所用的表达式，如果变量名加上()，得到的结果和不加()不同</p>
</blockquote>
<ul>
<li>如果加上一个 or 多个（），编译器会把变量看做表达式</li>
<li>不加括号，则得到变量的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">(i) = <span class="number">3</span>; <span class="comment">// (i)可以被赋值</span></span><br><span class="line"><span class="comment">// (i)被看做一个表达式，(i)可以被赋值，所以会得到引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d = i;</span><br><span class="line"><span class="comment">// i 是一个变量，返回其实际类型</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;</span><br></pre></td></tr></table></figure>
<img src="https://raw.githubusercontent.com/VMS-zhang/pic/master/img/20220503001716.png"></li>
</ul>
<p>decltpye((variable)) 双层括号的结果永远是引用;decltpye(variable)只有当变量本身是引用类型时候才是引用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
