<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/27/LevelDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/27/LevelDB/" class="post-title-link" itemprop="url">LevelDB</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-27 17:48:46 / Modified: 19:06:59" itemprop="dateCreated datePublished" datetime="2022-04-27T17:48:46+08:00">2022-04-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LevelDB/" itemprop="url" rel="index"><span itemprop="name">LevelDB</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class LEVELDB_EXPORT Slice &#123;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  // 这里的私有变量形式为 variable_，和 std 库还是有点儿区别的</span><br><span class="line"></span><br><span class="line">  const char* data_;</span><br><span class="line"></span><br><span class="line">  size_t size_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为标准库的string没有提供startWith&#x2F;removePrefix等功能，所以leveldb自行封装了一下string。 </p>
<p>Slice本身并不负责内存分配，只是简单的接收外部传入的指针。 </p>
<h2 id="Status返回码"><a href="#Status返回码" class="headerlink" title="Status返回码"></a>Status返回码</h2><p><em>leveldb 状态定义，在一个项目里面做统一的状态定义，是一个好习惯。唯一不足的时 Status 没办法扩展</em> </p>
<p><em>Status 里面的方法是一个具体的实现，没有做过多的抽象，如果要扩展的话一方面需要在 Code 枚举类中添加，另一方面需要添加对应的函数.</em> </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhhNGZiMjdiMTlhM2MyMjBjM2Y3YTNkZmU2NWMyMzVfalVGQWRBMlplM0xUN1hQcThKbTljTEduRWRabERTQTZfVG9rZW46Ym94Y25YcnA1c1J5RUZmOXlvdE9PWFc4cTJnXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">  // OK status has a null state_.  Otherwise, state_ is a new[] array</span><br><span class="line"></span><br><span class="line">  // of the following form:</span><br><span class="line"></span><br><span class="line">  //    state_[0..3] == length of message</span><br><span class="line"></span><br><span class="line">  //    state_[4]    == code</span><br><span class="line"></span><br><span class="line">  //    state_[5..]  == message</span><br><span class="line"></span><br><span class="line">  // 分配在堆上的错误状态，如果是成功的话，state_ 的值为 nullptr</span><br><span class="line"></span><br><span class="line">  const char* state_;</span><br><span class="line">class LEVELDB_EXPORT Status &#123;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  // Create a success status.</span><br><span class="line"></span><br><span class="line">  Status() noexcept : state_(nullptr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 因为是 new 出来的一个 array，所以也得使用 delete[]</span><br><span class="line"></span><br><span class="line">  ~Status() &#123; delete[] state_; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 下面的四个方法就是标准的拷贝构造、拷贝赋值、移动构造和移动赋值函数了</span><br><span class="line"></span><br><span class="line">  Status(const Status&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Status&amp; operator=(const Status&amp; rhs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Status(Status&amp;&amp; rhs) noexcept : state_(rhs.state_) &#123; rhs.state_ = nullptr; &#125;</span><br><span class="line"></span><br><span class="line">  Status&amp; operator=(Status&amp;&amp; rhs) noexcept;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Return a success status.</span><br><span class="line"></span><br><span class="line">  static Status OK() &#123; return Status(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Return error status of an appropriate type.</span><br><span class="line"></span><br><span class="line">  // msg2 通常用于存储系统调用所返回的错误码，也就是 errno</span><br><span class="line"></span><br><span class="line">  static Status NotFound(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123;</span><br><span class="line"></span><br><span class="line">    return Status(kNotFound, msg, msg2);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Status Corruption(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123;</span><br><span class="line"></span><br><span class="line">    return Status(kCorruption, msg, msg2);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Status NotSupported(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123;</span><br><span class="line"></span><br><span class="line">    return Status(kNotSupported, msg, msg2);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Status InvalidArgument(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123;</span><br><span class="line"></span><br><span class="line">    return Status(kInvalidArgument, msg, msg2);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static Status IOError(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123;</span><br><span class="line"></span><br><span class="line">    return Status(kIOError, msg, msg2);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Returns true iff the status indicates success.</span><br><span class="line"></span><br><span class="line">  bool ok() const &#123; return (state_ == nullptr); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Returns true iff the status indicates a NotFound error.</span><br><span class="line"></span><br><span class="line">  bool IsNotFound() const &#123; return code() == kNotFound; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Returns true iff the status indicates a Corruption error.</span><br><span class="line"></span><br><span class="line">  bool IsCorruption() const &#123; return code() == kCorruption; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Returns true iff the status indicates an IOError.</span><br><span class="line"></span><br><span class="line">  bool IsIOError() const &#123; return code() == kIOError; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Returns true iff the status indicates a NotSupportedError.</span><br><span class="line"></span><br><span class="line">  bool IsNotSupportedError() const &#123; return code() == kNotSupported; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Returns true iff the status indicates an InvalidArgument.</span><br><span class="line"></span><br><span class="line">  bool IsInvalidArgument() const &#123; return code() == kInvalidArgument; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Return a string representation of this status suitable for printing.</span><br><span class="line"></span><br><span class="line">  // Returns the string &quot;OK&quot; for success.</span><br><span class="line"></span><br><span class="line">  std::string ToString() const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  enum Code &#123;</span><br><span class="line"></span><br><span class="line">    kOk = 0,</span><br><span class="line"></span><br><span class="line">    kNotFound = 1,</span><br><span class="line"></span><br><span class="line">    kCorruption = 2,</span><br><span class="line"></span><br><span class="line">    kNotSupported = 3,</span><br><span class="line"></span><br><span class="line">    kInvalidArgument = 4,</span><br><span class="line"></span><br><span class="line">    kIOError = 5</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Code code() const &#123;</span><br><span class="line"></span><br><span class="line">    return (state_ == nullptr) ? kOk : static_cast&lt;Code&gt;(state_[4]);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Status(Code code, const Slice&amp; msg, const Slice&amp; msg2);</span><br><span class="line"></span><br><span class="line">  static const char* CopyState(const char* s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // OK status has a null state_.  Otherwise, state_ is a new[] array</span><br><span class="line"></span><br><span class="line">  // of the following form:</span><br><span class="line"></span><br><span class="line">  //    state_[0..3] == length of message</span><br><span class="line"></span><br><span class="line">  //    state_[4]    == code</span><br><span class="line"></span><br><span class="line">  //    state_[5..]  == message</span><br><span class="line"></span><br><span class="line">  // 分配在堆上的错误状态，如果是成功的话，state_ 的值为 nullptr</span><br><span class="line"></span><br><span class="line">  const char* state_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">Status::Status(Code code, const Slice&amp; msg, const Slice&amp; msg2) &#123;</span><br><span class="line"></span><br><span class="line">  // Status 的组成: 4 字节的 msg 长度 + 1 字节的状态码 + msg</span><br><span class="line"></span><br><span class="line">  assert(code != kOk);</span><br><span class="line"></span><br><span class="line">  // 将 size_t 强制类型转换成 uint32_t</span><br><span class="line"></span><br><span class="line">  const uint32_t len1 = static_cast&lt;uint32_t&gt;(msg.size());</span><br><span class="line"></span><br><span class="line">  const uint32_t len2 = static_cast&lt;uint32_t&gt;(msg2.size());</span><br><span class="line"></span><br><span class="line">  const uint32_t size = len1 + (len2 ? (2 + len2) : 0);</span><br><span class="line"></span><br><span class="line">  // 5 就是 4 字节的 msg 长度 + 1 字节的状态码</span><br><span class="line"></span><br><span class="line">  char* result = new char[size + 5];</span><br><span class="line"></span><br><span class="line">  std::memcpy(result, &amp;size, sizeof(size));</span><br><span class="line"></span><br><span class="line">  result[4] = static_cast&lt;char&gt;(code);</span><br><span class="line"></span><br><span class="line">  std::memcpy(result + 5, msg.data(), len1);</span><br><span class="line"></span><br><span class="line">  if (len2) &#123;</span><br><span class="line"></span><br><span class="line">    result[5 + len1] = &#x27;:&#x27;;</span><br><span class="line"></span><br><span class="line">    result[6 + len1] = &#x27; &#x27;;</span><br><span class="line"></span><br><span class="line">    std::memcpy(result + 7 + len1, msg2.data(), len2);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  state_ = result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Skiplist"><a href="#Skiplist" class="headerlink" title="Skiplist"></a>Skiplist</h2><p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=MDM0MzIxYjY3Y2FmNjc2MWUyMWUzN2QxYTg2NDMyZGRfMHpZVmxGT3JvcHFmUHliU1hiUHBGalNWaTVrcG5UQ3FfVG9rZW46Ym94Y25CVW5LdVh0UFFBZXFNRHBvRWliVTViXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/<span class="emphasis">*</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"> *</span> SkipList 属于 leveldb 中的核心数据结构，也是 memory table 的具体实现</span><br><span class="line"></span><br><span class="line"><span class="bullet"> *</span></span><br><span class="line"></span><br><span class="line"> <span class="emphasis">* SkipList 的实现挺有意思的，leveldb 是一个 key-value DB，但是 SkipList 类中只定义了 Key，</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"> *</span> 而没有定义 value。这是为什么?</span><br><span class="line"></span><br><span class="line"><span class="bullet"> *</span></span><br><span class="line"></span><br><span class="line"> <span class="emphasis">* 因为 leveldb 直接将 User Key 和 User Value 打包成了一个更大的 Key，塞到了 Skip List 中。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"> *</span> </span><br><span class="line"></span><br><span class="line"><span class="bullet"> *</span> ┌───────────────┬─────────────────┬────────────────────────────┬───────────────┬───────────────┐</span><br><span class="line"></span><br><span class="line"><span class="bullet"> *</span> │ size(varint32)│ User Key(string)│Sequence Number | kValueType│ size(varint32)│  User Value   │</span><br><span class="line"></span><br><span class="line"><span class="bullet"> *</span> └───────────────┴─────────────────┴────────────────────────────┴───────────────┴───────────────┘</span><br><span class="line"></span><br><span class="line"><span class="bullet"> *</span>        ↑</span><br><span class="line"></span><br><span class="line"><span class="bullet"> *</span>  值为 user<span class="emphasis">_key.size() + 8</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"> */</span></span><br></pre></td></tr></table></figure>

<p>SkipList的Node： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line">// Implementation details follow</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line"> * Node 中使用了比较多的关于指令重排的内容。</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * 需要注意的是，memory ordering 是针对于单线程而来的，也就是同一个线程内的指令重排情况，比如</span><br><span class="line"></span><br><span class="line"> * 现在有 2 条语句:</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> *  x = 100;</span><br><span class="line"></span><br><span class="line"> *  y.store();</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * 其中 x 的写入是非原子性的，而 y 的写入是原子性的，不管我们使用何种 memory ordering，y 的原子</span><br><span class="line"></span><br><span class="line"> * 写入永远是满足的，也就是说，y.store() 必然是多个线程的一个同步点。</span><br><span class="line"></span><br><span class="line">   但是，由于指令重排的原因，x = 100;</span><br><span class="line"></span><br><span class="line"> * 可能会在 y.store(); 之后执行，也可能会在其之前执行。memory ordering 限制的就是这个。</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * 1. Relaxed ordering</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * Relaxed ordering，也就是 std::memory_order_relaxed，</span><br><span class="line"></span><br><span class="line">   不对重排进行任何限制，只保证相关内存操作的原子性。</span><br><span class="line"></span><br><span class="line"> * 原子操作之前或者是之后的指令怎么被重排，我们并不关心，</span><br><span class="line"></span><br><span class="line">   反正保证对内存的操作是原子性的就行了。通常用于计数器等场景中</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * 2. Release-Acquire ordering</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * Release-Acquire ordering 由两个参数所指定，</span><br><span class="line"></span><br><span class="line"> 一个是 std::memory_order_acquire，用于 load() 方法，</span><br><span class="line"></span><br><span class="line"> * 一个则是 std::memory_order_release， 用于 store() 方法。</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * std::memory_order_acquire 表示在 load() 之后的所有读写操作，不允许被重排到这个 load() 的前面。</span><br><span class="line"></span><br><span class="line"> * std::memory_order_release 表示在 store() 之前的所有读写操作，不允许被重排到这个 store() 的后面</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line"></span><br><span class="line">struct SkipList&lt;Key, Comparator&gt;::Node &#123;</span><br><span class="line"></span><br><span class="line">  explicit Node(const Key&amp; k) : key(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Key const key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Accessors/mutators for links.  Wrapped in methods so we can</span><br><span class="line"></span><br><span class="line">  // add the appropriate barriers as necessary.</span><br><span class="line"></span><br><span class="line">  Node* Next(int n) &#123;</span><br><span class="line"></span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line"></span><br><span class="line">    // Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span><br><span class="line"></span><br><span class="line">    // version of the returned Node.</span><br><span class="line"></span><br><span class="line">    return next_[n].load(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void SetNext(int n, Node* x) &#123;</span><br><span class="line"></span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line"></span><br><span class="line">    // Use a &#x27;release store&#x27; so that anybody who reads through this</span><br><span class="line"></span><br><span class="line">    // pointer observes a fully initialized version of the inserted node.</span><br><span class="line"></span><br><span class="line">    next_[n].store(x, std::memory_order_release);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // No-barrier variants that can be safely used in a few locations.</span><br><span class="line"></span><br><span class="line">  Node* NoBarrier_Next(int n) &#123;</span><br><span class="line"></span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line"></span><br><span class="line">    return next_[n].load(std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void NoBarrier_SetNext(int n, Node* x) &#123;</span><br><span class="line"></span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line"></span><br><span class="line">    next_[n].store(x, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  // next[0]是倒数第一层，next[1]是倒数第二层</span><br><span class="line"></span><br><span class="line">  // Array of length equal to the node height.  next_[0] is lowest level link.</span><br><span class="line"></span><br><span class="line">  // 1) 这里提前声明并申请了一个内存，用于存储第 0 层的数据，因为第 0 层必然存在数据。</span><br><span class="line"></span><br><span class="line">  // 2) 这里的数组长度其实就是层高，假设 next_ 长度为 n，那么就会从 next_[n-1] 开始查找。</span><br><span class="line"></span><br><span class="line">  // 3) 因为 skip list 的 level 并不会太大，使用数组存储 Node 指针的话对 CPU 内存更友好</span><br><span class="line"></span><br><span class="line">  // https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;Node*&gt; next_[1];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line"></span><br><span class="line">class SkipList &#123;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  struct Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  // 经验值</span><br><span class="line"></span><br><span class="line">  enum &#123; kMaxHeight = 12 &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  inline int GetMaxHeight() const &#123;</span><br><span class="line"></span><br><span class="line">    // 简单的原子性取出层高，无所谓指令重排</span><br><span class="line"></span><br><span class="line">    return max_height_.load(std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Node* NewNode(const Key&amp; key, int height);</span><br><span class="line"></span><br><span class="line">  int RandomHeight();</span><br><span class="line"></span><br><span class="line">  bool Equal(const Key&amp; a, const Key&amp; b) const &#123; return (compare_(a, b) == 0); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Return true if key is greater than the data stored in &quot;n&quot;</span><br><span class="line"></span><br><span class="line">  bool KeyIsAfterNode(const Key&amp; key, Node* n) const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Return the earliest node that comes at or after key.</span><br><span class="line"></span><br><span class="line">  // Return nullptr if there is no such node.</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line"></span><br><span class="line">  // If prev is non-null, fills prev[level] with pointer to previous</span><br><span class="line"></span><br><span class="line">  // node at &quot;level&quot; for every level in [0..max_height_-1].</span><br><span class="line"></span><br><span class="line">  Node* FindGreaterOrEqual(const Key&amp; key, Node** prev) const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Return the latest node with a key &lt; key.</span><br><span class="line"></span><br><span class="line">  // Return head_ if there is no such node.</span><br><span class="line"></span><br><span class="line">  Node* FindLessThan(const Key&amp; key) const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Return the last node in the list.</span><br><span class="line"></span><br><span class="line">  // Return head_ if list is empty.</span><br><span class="line"></span><br><span class="line">  Node* FindLast() const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Immutable after construction</span><br><span class="line"></span><br><span class="line">  // 比较器</span><br><span class="line"></span><br><span class="line">  Comparator const compare_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // leveldb 自己封装的一个内存分配器</span><br><span class="line"></span><br><span class="line">  Arena* const arena_;  // Arena used for allocations of nodes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 虚拟头结点，也就是 Dummy Head</span><br><span class="line"></span><br><span class="line">  Node* const head_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Modified only by Insert().  Read racily by readers, but stale</span><br><span class="line"></span><br><span class="line">  // values are ok.</span><br><span class="line"></span><br><span class="line">  // 原子变量的层高</span><br><span class="line"></span><br><span class="line">  std::atomic&lt;int&gt; max_height_;  // Height of the entire list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Read/written only by Insert().</span><br><span class="line"></span><br><span class="line">  Random rnd_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  // Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span><br><span class="line"></span><br><span class="line">  // and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span><br><span class="line"></span><br><span class="line">  // must remain allocated for the lifetime of the skiplist object.</span><br><span class="line"></span><br><span class="line">  explicit SkipList(Comparator cmp, Arena* arena);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 不允许进行拷贝构造与拷贝赋值</span><br><span class="line"></span><br><span class="line">  SkipList(const SkipList&amp;) = delete;</span><br><span class="line"></span><br><span class="line">  SkipList&amp; operator=(const SkipList&amp;) = delete;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Insert key into the list.</span><br><span class="line"></span><br><span class="line">  // REQUIRES: nothing that compares equal to key is currently in the list.</span><br><span class="line"></span><br><span class="line">  void Insert(const Key&amp; key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Returns true iff an entry that compares equal to key is in the list.</span><br><span class="line"></span><br><span class="line">  // (iff, if and only if)</span><br><span class="line"></span><br><span class="line">  bool Contains(const Key&amp; key) const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Iteration over the contents of a skip list</span><br><span class="line"></span><br><span class="line">  class Iterator &#123;</span><br><span class="line"></span><br><span class="line">   public:</span><br><span class="line"></span><br><span class="line">    // Initialize an iterator over the specified list.</span><br><span class="line"></span><br><span class="line">    // The returned iterator is not valid.</span><br><span class="line"></span><br><span class="line">    explicit Iterator(const SkipList* list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Returns true iff the iterator is positioned at a valid node.</span><br><span class="line"></span><br><span class="line">    bool Valid() const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Returns the key at the current position.</span><br><span class="line"></span><br><span class="line">    // REQUIRES: Valid()</span><br><span class="line"></span><br><span class="line">    const Key&amp; key() const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Advances to the next position.</span><br><span class="line"></span><br><span class="line">    // REQUIRES: Valid()</span><br><span class="line"></span><br><span class="line">    void Next();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Advances to the previous position.</span><br><span class="line"></span><br><span class="line">    // REQUIRES: Valid()</span><br><span class="line"></span><br><span class="line">    void Prev();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Advance to the first entry with a key &gt;= target</span><br><span class="line"></span><br><span class="line">    void Seek(const Key&amp; target);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Position at the first entry in list.</span><br><span class="line"></span><br><span class="line">    // Final state of iterator is Valid() iff list is not empty.</span><br><span class="line"></span><br><span class="line">    void SeekToFirst();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Position at the last entry in list.</span><br><span class="line"></span><br><span class="line">    // Final state of iterator is Valid() iff list is not empty.</span><br><span class="line"></span><br><span class="line">    void SeekToLast();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   private:</span><br><span class="line"></span><br><span class="line">    const SkipList* list_;</span><br><span class="line"></span><br><span class="line">    Node* node_;</span><br><span class="line"></span><br><span class="line">    // Intentionally copyable</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Insert </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line"></span><br><span class="line">void SkipList&lt;Key, Comparator&gt;::Insert(const Key&amp; key) &#123;</span><br><span class="line"></span><br><span class="line">  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span><br><span class="line"></span><br><span class="line">  // here since Insert() is externally synchronized.</span><br><span class="line"></span><br><span class="line">  // 指针的数组，因为需要修改每层前驱节点的数据，所以需要二维指针</span><br><span class="line"></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line"></span><br><span class="line">  // 存储每层中该节点的前一个节点</span><br><span class="line"></span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Our data structure does not allow duplicate insertion</span><br><span class="line"></span><br><span class="line">  assert(x == nullptr || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  int height = RandomHeight();</span><br><span class="line"></span><br><span class="line">  if (height &gt; GetMaxHeight()) &#123;</span><br><span class="line"></span><br><span class="line">    // 层高不够则使用head_作为新层的头结点</span><br><span class="line"></span><br><span class="line">    for (int i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class="line"></span><br><span class="line">      prev[i] = head_;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // It is ok to mutate max_height_ without any synchronization</span><br><span class="line"></span><br><span class="line">    // with concurrent readers.  A concurrent reader that observes</span><br><span class="line"></span><br><span class="line">    // the new value of max_height_ will see either the old value of</span><br><span class="line"></span><br><span class="line">    // new level pointers from head_ (nullptr), or a new value set in</span><br><span class="line"></span><br><span class="line">    // the loop below.  In the former case the reader will</span><br><span class="line"></span><br><span class="line">    // immediately drop to the next level since nullptr sorts after all</span><br><span class="line"></span><br><span class="line">    // keys.  In the latter case the reader will use the new node.</span><br><span class="line"></span><br><span class="line">    max_height_.store(height, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  x = NewNode(key, height);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; height; i++) &#123;</span><br><span class="line"></span><br><span class="line">    // NoBarrier_SetNext() suffices since we will add a barrier when</span><br><span class="line"></span><br><span class="line">    // we publish a pointer to &quot;x&quot; in prev[i].</span><br><span class="line"></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line"></span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 在 Skip List 中寻找第一个大于等于 key 的节点，同时使用 prev 数组记录下该节点的每一个 level</span><br><span class="line"></span><br><span class="line"> * 的前驱节点，用于辅助实现 insert 和 delete 操作，把 prev 数组当作是单向链表的 prev 节点就可以了</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> *    5-&gt;10-&gt;18-&gt;22-&gt;35-&gt;44</span><br><span class="line"></span><br><span class="line"> *           ↑   ↑</span><br><span class="line"></span><br><span class="line"> *         prev node</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * 如上面的单链表，node 是我们要查找的节点，当我们返回给调用方之后，如果调用方需要做删除操作的话，</span><br><span class="line"></span><br><span class="line"> * 就可以这样来做:</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> *    prev-&gt;next = node-&gt;next;</span><br><span class="line"></span><br><span class="line"> *    node-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line"> *    delete node;</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line"> * 很好的一个设计，在查找的过程中记录一些其他接口所需的信息，最大可能地进行代码复用。*/</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, class Comparator&gt;</span><br><span class="line"></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line"></span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(const Key&amp; key,</span><br><span class="line"></span><br><span class="line">                                              Node** prev) const &#123;</span><br><span class="line"></span><br><span class="line">  Node* x = head_;</span><br><span class="line"></span><br><span class="line">  // index 是从 0 开始的，所以需要减去 1</span><br><span class="line"></span><br><span class="line">  // 从最高层开始往下找</span><br><span class="line"></span><br><span class="line">  int level = GetMaxHeight() - 1;</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line"></span><br><span class="line">    /* 获取当前 level 层的下一个节点 */</span><br><span class="line"></span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* KeyIsAfterNode 实际上就是使用 Compactor 比较 Key 和 next-&gt;key 的大小关系。</span><br><span class="line"></span><br><span class="line">     * 如果当前待查找节点比 next-&gt;key 还要大的话，那么就继续在同一层向后查找 */</span><br><span class="line"></span><br><span class="line">    if (KeyIsAfterNode(key, next)) &#123;</span><br><span class="line"></span><br><span class="line">      // Keep searching in this list</span><br><span class="line"></span><br><span class="line">      x = next;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // prev 数组主要记录的就是每一层的 prev 节点，主要用于插入和删除时使用</span><br><span class="line"></span><br><span class="line">      if (prev != nullptr) prev[level] = x;</span><br><span class="line"></span><br><span class="line">      if (level == 0) &#123;</span><br><span class="line"></span><br><span class="line">        return next;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        // Switch to next list</span><br><span class="line"></span><br><span class="line">        level--;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><p>Cache中有两个链表，一个是inuse，一个是idle，inuse中的数据是被client引用的数据，而idle是没有被用户引用的数据。 </p>
<p>分成两个链表可以： </p>
<ol>
<li><strong>inuse的不需要排序，但是idle的都需要排序，所以节省了inuse的排序时间</strong> </li>
<li><strong>更清晰的区分已经被使用的和没有被使用的。</strong></li>
</ol>
<p>注：这个的ref和LevelDB的refs不同。 </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=MmRmZGFlZTYzY2QxNDU4YmRiMjFlMWYxM2Q1YTQzMGNfUGZJTXU3eTBFTHVNNDBPTWlCUGNHTVB5UGJRdjZuRVlfVG9rZW46Ym94Y25rSVZMZ2pnRGhoQWViUm9tWWk5QldnXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>两个链表中的数据是<strong>互斥</strong>的。缓存中的数据要么在inuse要么在lru中，不可能同时存在。 </p>
<ol>
<li><strong>in-use 链表</strong>。所有正在被客户端使用的数据条目（an kv item）都存在该链表中，该链表是无序的，因为在容量不够时，此链表中的条目是一定不能够被驱逐的，因此也<strong>并不需要维持一个驱逐顺序。</strong> </li>
<li><strong>lru 链表</strong>。所有已经不再为客户端使用的条目都放在 lru 链表中，该链表按最近使用时间有序，当容量不够用时，会驱逐此链表中最久没有被使用的条目。</li>
</ol>
<p>两个链表的底层都是LRUHandle。 </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=YTYzNmEzNjZjZDRjODc3OGE3YjhlMzEzYTJhZmRmZTNfTXNTNmdURE9MeFFHUGY5TDJIN000eWxLbHI1Z3lSeDRfVG9rZW46Ym94Y250Y0NUTmZxbzY0S0hsNVlFTXh0ZDNiXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>LRUHandle </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct LRUHandle &#123;</span><br><span class="line"></span><br><span class="line">  void* value;</span><br><span class="line"></span><br><span class="line">  void (*deleter)(const Slice&amp;, void* value); // 释放 key,value 空间的用户回调</span><br><span class="line"></span><br><span class="line">  LRUHandle* next_hash;  // 用于 hashtable 中链表处理冲突</span><br><span class="line"></span><br><span class="line">  LRUHandle* next;       // 用于双向链表中维护 LRU 顺序</span><br><span class="line"></span><br><span class="line">  LRUHandle* prev;</span><br><span class="line"></span><br><span class="line">  size_t charge;     // TODO(opt): Only allow uint32_t?</span><br><span class="line"></span><br><span class="line">  size_t key_length;</span><br><span class="line"></span><br><span class="line">  bool in_cache;     // 该 handle 是否在 cache table 中</span><br><span class="line"></span><br><span class="line">  uint32_t refs;     // 该 handle 被引用的次数</span><br><span class="line"></span><br><span class="line">  uint32_t hash;     // key 的 hash 值，用于确定分片和快速比较</span><br><span class="line"></span><br><span class="line">  char key_data[1];  // key 的起始</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Slice key() const &#123;</span><br><span class="line"></span><br><span class="line">    // next_ is only equal to this if the LRU handle is the list head of an</span><br><span class="line"></span><br><span class="line">    // empty list. List heads never have meaningful keys.</span><br><span class="line"></span><br><span class="line">    assert(next != this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return Slice(key_data, key_length);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现时候，Cache引用也算做一个引用，所以Insert时候，refs&#x3D;2的：一个是客户端引用，一个是LRUCache的引用。 </p>
<p><code>**refs==1 &amp;&amp; in_cache**</code><strong>表示只被lrucache引用；</strong><code>**refs&gt;1 &amp;&amp; in_cache**</code><strong>表示被客户端引用了。</strong> </p>
<h2 id="HandleTable"><a href="#HandleTable" class="headerlink" title="HandleTable"></a>HandleTable</h2><p>哈希表，使用位运算确定桶，同一个桶使用链表处理冲突；链表的数据是无序的，所以需要遍历链表。 </p>
<p>在其中增删节点的时候，只需要返回其前驱节点的指针，修改前驱节点的next指向即可。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle** FindPointer(const Slice&amp; key, uint32_t hash) &#123;</span><br><span class="line"></span><br><span class="line">  // 位运算，确定桶</span><br><span class="line"></span><br><span class="line">  LRUHandle** ptr = &amp;list_[hash &amp; (length_ - 1)];</span><br><span class="line"></span><br><span class="line">  // 找到其前驱节点</span><br><span class="line"></span><br><span class="line">  while (*ptr != nullptr &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 指针的指针，用来修改指针指向的数据</span><br><span class="line"></span><br><span class="line">  return ptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">LRUHandle* Insert(LRUHandle* h) &#123;</span><br><span class="line"></span><br><span class="line">  LRUHandle** ptr = FindPointer(h-&gt;key(), h-&gt;hash);</span><br><span class="line"></span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line"></span><br><span class="line">  h-&gt;next_hash = (old == nullptr ? nullptr : old-&gt;next_hash);</span><br><span class="line"></span><br><span class="line">  *ptr = h; // 修改前驱节点的后继指针，使前驱节点指向新加的节点</span><br><span class="line"></span><br><span class="line">  if (old == nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    ++elems_; // 原先没有这个数据，则已有的元素格式+1</span><br><span class="line"></span><br><span class="line">    if (elems_ &gt; length_) &#123; // 已有的数据&gt;长度则resize</span><br><span class="line"></span><br><span class="line">      // Since each cache entry is fairly large, we aim for a small</span><br><span class="line"></span><br><span class="line">      // average linked list length (&lt;= 1).</span><br><span class="line"></span><br><span class="line">      Resize();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回原来的数据，删除掉</span><br><span class="line"></span><br><span class="line">  return old;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Cache::Handle* LRUCache::Insert(const Slice&amp; key, uint32_t hash, void* value,</span><br><span class="line"></span><br><span class="line">                                size_t charge,</span><br><span class="line"></span><br><span class="line">                                void (*deleter)(const Slice&amp; key,</span><br><span class="line"></span><br><span class="line">                                                void* value)) &#123;</span><br><span class="line"></span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 构建数据条目句柄</span><br><span class="line"></span><br><span class="line">  LRUHandle* e =</span><br><span class="line"></span><br><span class="line">      reinterpret_cast&lt;LRUHandle*&gt;(malloc(sizeof(LRUHandle) - 1 + key.size()));</span><br><span class="line"></span><br><span class="line">  e-&gt;value = value;</span><br><span class="line"></span><br><span class="line">  e-&gt;deleter = deleter;</span><br><span class="line"></span><br><span class="line">  e-&gt;charge = charge;</span><br><span class="line"></span><br><span class="line">  e-&gt;key_length = key.size();</span><br><span class="line"></span><br><span class="line">  e-&gt;hash = hash;</span><br><span class="line"></span><br><span class="line">  e-&gt;in_cache = false;</span><br><span class="line"></span><br><span class="line">  e-&gt;refs = 1;  // 客户端引用</span><br><span class="line"></span><br><span class="line">  std::memcpy(e-&gt;key_data, key.data(), key.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (capacity_ &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    e-&gt;refs++;  // 缓存本身引用</span><br><span class="line"></span><br><span class="line">    e-&gt;in_cache = true;</span><br><span class="line"></span><br><span class="line">    LRU_Append(&amp;in_use_, e); // 加入inuse链表</span><br><span class="line"></span><br><span class="line">    usage_ += charge;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    FinishErase(table_.Insert(e)); // 字典如果是替换，要删除原来数据</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;  // capacity_==0 时表示关闭缓存，不进行任何缓存</span><br><span class="line"></span><br><span class="line">    // next 会在 key() 函数中被 assert 测试，因此要初始化一下</span><br><span class="line"></span><br><span class="line">    e-&gt;next = nullptr;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 当超数据条目超出容量时，根据 LRU 策略将不被客户端引用的数据条目驱逐出内存</span><br><span class="line"></span><br><span class="line">  while (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;</span><br><span class="line"></span><br><span class="line">    LRUHandle* old = lru_.next;</span><br><span class="line"></span><br><span class="line">    assert(old-&gt;refs == 1);</span><br><span class="line"></span><br><span class="line">    bool erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash));</span><br><span class="line"></span><br><span class="line">    if (!erased) &#123;  // to avoid unused variable when compiled NDEBUG</span><br><span class="line"></span><br><span class="line">      assert(erased);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return reinterpret_cast&lt;Cache::Handle*&gt;(e);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// If e != nullptr, finish removing *e from the cache; it has already been</span><br><span class="line"></span><br><span class="line">// removed from the hash table.  Return whether e != nullptr.</span><br><span class="line"></span><br><span class="line">bool LRUCache::FinishErase(LRUHandle* e) &#123;</span><br><span class="line"></span><br><span class="line">  if (e != nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    assert(e-&gt;in_cache);</span><br><span class="line"></span><br><span class="line">    LRU_Remove(e); </span><br><span class="line"></span><br><span class="line">    e-&gt;in_cache = false;</span><br><span class="line"></span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line"></span><br><span class="line">    Unref(e);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return e != nullptr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void LRUCache::Unref(LRUHandle* e) &#123;</span><br><span class="line"></span><br><span class="line">  assert(e-&gt;refs &gt; 0);</span><br><span class="line"></span><br><span class="line">  e-&gt;refs--;</span><br><span class="line"></span><br><span class="line">  if (e-&gt;refs == 0) &#123;  // Deallocate.</span><br><span class="line"></span><br><span class="line">    assert(!e-&gt;in_cache);</span><br><span class="line"></span><br><span class="line">    (*e-&gt;deleter)(e-&gt;key(), e-&gt;value);</span><br><span class="line"></span><br><span class="line">    free(e);</span><br><span class="line"></span><br><span class="line">  &#125; else if (e-&gt;in_cache &amp;&amp; e-&gt;refs == 1) &#123;</span><br><span class="line"></span><br><span class="line">    // No longer in use; move to lru_ list.</span><br><span class="line"></span><br><span class="line">    LRU_Remove(e);</span><br><span class="line"></span><br><span class="line">    LRU_Append(&amp;lru_, e);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Varint"><a href="#Varint" class="headerlink" title="Varint"></a>Varint</h2><p>varint 是一种使用一个或多个字节序列化整数的方法，会把整数编码为变长字节。对于 32 位整型经过 varint 编码后需要 <code>1~5</code> 个字节，小的数字使用 1 字节，大的数字使用 5 字节。而 64 位整数根据 varint 编码后需要 <code>1~10</code> 个字节。在实际业务场景中，小整数的使用频率要远超于大整数的使用频率，因此使用 varint 编码能够有效的节省内存和硬盘的存储空间。 </p>
<p>util&#x2F;coding.h </p>
<p>在Leveldb中不管是什么模式存储，全部转为小端模式。 </p>
<p>LevelDB使用两种类型的编码格式，一种是FixedInt，另一个是varint。 </p>
<ul>
<li>FixedInt就是将uint32_t &#x3D;&gt; char*</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/* 简单地将 unint32 写入至 dst 中，并没有使用 varint */</span><br><span class="line"></span><br><span class="line">inline void EncodeFixed32(char* dst, uint32_t value) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 这里补充一个 static_cast 和 reinterpret_cast 之间的区别</span><br><span class="line"></span><br><span class="line">   *</span><br><span class="line"></span><br><span class="line">   * static_cast 主要用于&quot;相关类型&quot;之间的强制类型转换，比如 double 转 int，double 转 float。</span><br><span class="line"></span><br><span class="line">   * 相关类型是指转换类型和待转换类型之间多少还有点儿关系，比如 double 和 int，它们都属于数字。</span><br><span class="line"></span><br><span class="line">   * 又比如将 void * 指针转换成其它类型的指针，比如 int *，这也没有问题。</span><br><span class="line"></span><br><span class="line">   * 但是如果把一个 long long 类型转换成一个指针类型，这就不属于&quot;相关类型&quot; 之间的范畴了。</span><br><span class="line"></span><br><span class="line">   *</span><br><span class="line"></span><br><span class="line">   * 另外一点就是基类指针转换成派生类指针时，虽然它们确实有关系，但是应该使用 dynamic_cast 完成。</span><br><span class="line"></span><br><span class="line">   *</span><br><span class="line"></span><br><span class="line">   * reinterpret_cast 则用于&quot;完全不相关类型&quot;之间的强制类型转换。reinterpret 可以翻译为重新释义，也就是</span><br><span class="line"></span><br><span class="line">   * 对目标对象的内存进行重新解释。此时我们可以将一个 long long 对象转换成一个指针类型，或者是将一个 char *</span><br><span class="line"></span><br><span class="line">   * 转换成一个 int *。</span><br><span class="line"></span><br><span class="line">   * */</span><br><span class="line"></span><br><span class="line">  uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 依次将 value 的 4 字节写入至 buffer 中，也就是写入到 dst 中。</span><br><span class="line"></span><br><span class="line">   * 并且可以看到，buffer[0] 写入的是 value 低 8 位，buffer[1] 写入的是第二个低 8 位。</span><br><span class="line"></span><br><span class="line">   * 因此，数据存放的方式是按照先低位后高位的顺序存放的，也就是说，leveldb 采用的是小端存储（Little-Endian）*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Recent clang and gcc optimize this to a single mov / str instruction.</span><br><span class="line"></span><br><span class="line">  buffer[0] = static_cast&lt;uint8_t&gt;(value);</span><br><span class="line"></span><br><span class="line">  buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8);</span><br><span class="line"></span><br><span class="line">  buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16);</span><br><span class="line"></span><br><span class="line">  buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 简单地将 unint64 写入至 dst 中，并没有使用 varint */</span><br><span class="line"></span><br><span class="line">inline void EncodeFixed64(char* dst, uint64_t value) &#123;</span><br><span class="line"></span><br><span class="line">  uint8_t* const buffer = reinterpret_cast&lt;uint8_t*&gt;(dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Recent clang and gcc optimize this to a single mov / str instruction.</span><br><span class="line"></span><br><span class="line">  buffer[0] = static_cast&lt;uint8_t&gt;(value);</span><br><span class="line"></span><br><span class="line">  buffer[1] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 8);</span><br><span class="line"></span><br><span class="line">  buffer[2] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 16);</span><br><span class="line"></span><br><span class="line">  buffer[3] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 24);</span><br><span class="line"></span><br><span class="line">  buffer[4] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 32);</span><br><span class="line"></span><br><span class="line">  buffer[5] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 40);</span><br><span class="line"></span><br><span class="line">  buffer[6] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 48);</span><br><span class="line"></span><br><span class="line">  buffer[7] = static_cast&lt;uint8_t&gt;(value &gt;&gt; 56);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>varint就是对整型进行变长编码，写入到dst中</li>
</ul>
<p>varint的时候，每个字节的最高位是保留位，1表示后面仍有数据，0表示当前字节就是结尾。 </p>
<p>varint 的每一个字节只能使用 7 位，所以当我们有一个 64 位长度的整型需要进行 varint 编码时，必须使用 10 个字节才能表示。这比原来的 8 字节还要多出 2 个字节，所以，varint 并不适合用于大整数占比非常多的情况。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* 注意，该方法调用后 dst 指针将会向后移动 1~10 字节，具体取决于 varint 编码大小 */</span><br><span class="line"></span><br><span class="line">char* EncodeVarint64(char* dst, uint64_t v) &#123;</span><br><span class="line"></span><br><span class="line">  /* 每一个字节有效位为 7，最大只能表示 2^7 - 1 = 127 */</span><br><span class="line"></span><br><span class="line">  static const int B = 128;</span><br><span class="line"></span><br><span class="line">  uint8_t* ptr = reinterpret_cast&lt;uint8_t*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  /* 当 v 大于 127 时，说明还需要一个字节来保存 */</span><br><span class="line"></span><br><span class="line">  while (v &gt;= B) &#123;</span><br><span class="line"></span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line"></span><br><span class="line">    v &gt;&gt;= 7;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *(ptr++) = static_cast&lt;uint8_t&gt;(v);</span><br><span class="line"></span><br><span class="line">  // 返回的时候ptr必然变化了！！！返回的是编码后的末尾</span><br><span class="line"></span><br><span class="line">  return reinterpret_cast&lt;char*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Key-Format"><a href="#Key-Format" class="headerlink" title="Key Format"></a>Key Format</h2><p>Key不仅仅需要保存user key的数据，还需要保存一个序号表示同一个user key的多个版本。 </p>
<ul>
<li>LevelDB使用一个全局递增的sequence number写入到key中，从而实现snapshot，本质上就是MVCC。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* ┌───────────────┬─────────────────┬────────────────────────────┬───────────────┬───────────────┐</span><br><span class="line"></span><br><span class="line">* │ size(varint32)│ User Key(string)│Sequence Number | kValueType│ size(varint32)│  User Value   │</span><br><span class="line"></span><br><span class="line">* └───────────────┴─────────────────┴────────────────────────────┴───────────────┴───────────────┘</span><br><span class="line"></span><br><span class="line">*        ↑</span><br><span class="line"></span><br><span class="line">*  值为 user_key.size() + 8</span><br></pre></td></tr></table></figure>

<p>在删除数据时候，实际上没有执行删除操作，而是追加一个删除标记（<em>kValueType）来表示删除。</em> </p>
<ol>
<li><h3 id="InternalKey-与-ParsedInternalKey"><a href="#InternalKey-与-ParsedInternalKey" class="headerlink" title="InternalKey 与 ParsedInternalKey"></a>InternalKey 与 ParsedInternalKey</h3></li>
</ol>
<p>InternalKey 是一个字符串，由userKey、sequence number、valueType组成。 </p>
<p>ParsedInternalKey是将InternalKey的三种数据解析出来。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ParsedInternalKey &#123;</span><br><span class="line"></span><br><span class="line">  Slice user_key;</span><br><span class="line"></span><br><span class="line">  SequenceNumber sequence;</span><br><span class="line"></span><br><span class="line">  ValueType type;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=NDU2ZWM3NTg1MmQ5ZjY3YmZhYzFlMTYwOWI2YmRhOWFfa2tmZUx4bzVocko3MUZhWFpIemw3RnJ1cXRpaUFhYUtfVG9rZW46Ym94Y243b2N2SU5xbXRlQ2JPRHAwVjZtOXpoXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>实际上InternalKey 并不是简单的拼接，而是将ValueType压缩到了低8bit中。 </p>
<p>Sequence number实际上最大值是（1&lt;&lt;56)-1，但是也是足够用的了。 </p>
<ol>
<li><h3 id="lookupKey-与-MemTableKey"><a href="#lookupKey-与-MemTableKey" class="headerlink" title="lookupKey 与 MemTableKey"></a>lookupKey 与 MemTableKey</h3></li>
</ol>
<p>查询一个key的时候，首先查询的是MemTable，然后查询Immutable以及硬盘中的SSTable。 </p>
<p>MemTable 所提供的 <code>Get()</code> 方法需要使用到 <code>LookupKey</code>，<code>LookupKey</code> 可以认为是一个“究极体”，从该对象中我们可以得到所有我们需要的信息，包括 User Key、User Key 的长度、Sequence Number 以及 Value Type。 </p>
<p><code>LookupKey</code> 其实就是在 <code>InternalKey</code> 的基础上，额外的添加了 User Key 的长度，这个长度是由 Varint 进行编码的。因此，程序为了能够正确的找到 User Key 和 Sequence Number 等信息，额外的使用了 3 个指针，如下图所示: </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJlZGViNGY0MGQ0Mzk3MjlhNGFlNzA5ZTZiZjE5YTFfR3ZsVTkyTk1tUjVsZTRaUENLWTBxUjRsaGI4dXgzSWZfVG9rZW46Ym94Y25LZXUxbmlaVkFqTlhGaHBjbnBFZ0RmXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>Size大小为UserKey的字节数+8，然后通过 <code>EncodeVarint32()</code> 方法进行编码，写入到字符串的头部。同时，对于 <code>LookupKey</code> 来说，其 Value Type 为 <code>kValueTypeForSeek</code>，其实也就是 <code>kTypeValue</code>。 </p>
<p>根据这三个指针，可以得到各种信息： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LookupKey</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 可以看到，MemTable Key 和 LookupKey 其实是等价的*/</span></span><br><span class="line"></span><br><span class="line">  Slice <span class="title function_">memtable_key</span><span class="params">()</span> const &#123; <span class="keyword">return</span> Slice(start_, end_ - start_); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 返回 InternalKey */</span></span><br><span class="line"></span><br><span class="line">  Slice <span class="title function_">internal_key</span><span class="params">()</span> const &#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* User Key 的话需要刨去最后的 (Sequence Number &lt;&lt; 8) | Value Type */</span></span><br><span class="line"></span><br><span class="line">  Slice <span class="title function_">user_key</span><span class="params">()</span> const &#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用SkipList来实现Memtable，并提供了Add将KV写入到Skip List。在SkipList的实现中，并没有Value的值，而是将User Key和User Value打包成了更大的一个key，直接塞到了SkipList中。 </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIyMTYyMTc1M2QzODYxZDJjYWRlY2QyY2FiNzkzMzJfQ3JHR1RWS3haVkxtVVRiOGJURTlqTVdMMVJoM0hpV3JfVG9rZW46Ym94Y25wMVM4MWhOTlRsZ2hRMVdoV1Fya2hnXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<h1 id="KV写入流程"><a href="#KV写入流程" class="headerlink" title="KV写入流程"></a>KV写入流程</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p><code>include/leveldb/db.h</code> 中的 <code>DB</code> 类提供了 leveldb 对外的抽象 API，该类中所有的函数均为纯虚函数，也就是说，<code>DB</code> 类其实就是一个 Interface。不过，由于 C++ 语法的特殊性，<code>DB</code> 类也可以对纯虚函数进行实现，并且 leveldb 也给出了默认实现。 </p>
<p>有两个类实现了 <code>DB</code> 接口，一个是位于 <code>db/db_test.cc</code> 文件中的 <code>ModelDB</code>，另一个则是位于 <code>db/db_impl.cc</code> 中的 <code>DBImpl</code>。很明显，<code>ModelDB</code> 主要用于测试，而 <code>DBImpl</code> 才是 leveldb 实现的核心类。我们只需要关注 <code>DBImpl::Put()</code> 和 <code>DBImpl::Write()</code> 这两个方法即可。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">struct WriteOptions &#123;</span><br><span class="line"></span><br><span class="line">    WriteOptions() = default;</span><br><span class="line"></span><br><span class="line">    bool sync = false;      /* 写入 WAL 时是否同步调用 fsync() */</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* DBImpl 实现的 Put() 方法，本质上还是调用了 leveldb 的默认实现 */</span><br><span class="line"></span><br><span class="line">Status DBImpl::Put(const WriteOptions&amp; o, const Slice&amp; key, const Slice&amp; val) &#123;</span><br><span class="line"></span><br><span class="line">  return DB::Put(o, key, val);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 真正的 Put() 方法实现 */</span><br><span class="line"></span><br><span class="line">Status DB::Put(const WriteOptions&amp; opt, const Slice&amp; key, const Slice&amp; value) &#123;</span><br><span class="line"></span><br><span class="line">  WriteBatch batch;</span><br><span class="line"></span><br><span class="line">  batch.Put(key, value);</span><br><span class="line"></span><br><span class="line">  return Write(opt, &amp;batch);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// Options that control write operations</span><br><span class="line"></span><br><span class="line">struct LEVELDB_EXPORT WriteOptions &#123;</span><br><span class="line"></span><br><span class="line">  WriteOptions() = default;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // If true, the write will be flushed from the operating system</span><br><span class="line"></span><br><span class="line">  // buffer cache (by calling WritableFile::Sync()) before the write</span><br><span class="line"></span><br><span class="line">  // is considered complete.  If this flag is true, writes will be</span><br><span class="line"></span><br><span class="line">  // slower.</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line"></span><br><span class="line">  // If this flag is false, and the machine crashes, some recent</span><br><span class="line"></span><br><span class="line">  // writes may be lost.  Note that if it is just the process that</span><br><span class="line"></span><br><span class="line">  // crashes (i.e., the machine does not reboot), no writes will be</span><br><span class="line"></span><br><span class="line">  // lost even if sync==false.</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line"></span><br><span class="line">  // In other words, a DB write with sync==false has similar</span><br><span class="line"></span><br><span class="line">  // crash semantics as the &quot;write()&quot; system call.  A DB write</span><br><span class="line"></span><br><span class="line">  // with sync==true has similar crash semantics to a &quot;write()&quot;</span><br><span class="line"></span><br><span class="line">  // system call followed by &quot;fsync()&quot;.</span><br><span class="line"></span><br><span class="line">  /* 写入预写日志后是否需要同步刷盘，对于不同的的数据需要不同的 Options 选项，</span><br><span class="line"></span><br><span class="line">   * 但是在绝大多数情况下该值为 true */</span><br><span class="line"></span><br><span class="line">  bool sync = false;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="WriteBatch：多个线程的数据打包"><a href="#WriteBatch：多个线程的数据打包" class="headerlink" title="WriteBatch：多个线程的数据打包"></a>WriteBatch：多个线程的数据打包</h2><p>WriteBatch是为了提高效率，把多个线程写入的kv写打包成一个WriteBatch对象，一次性写入。 </p>
<p>WriteBatch实际上是一个std::String对象。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class WriteBatch &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    WriteBatch();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    void Put(const Slice&amp; key, const Slice&amp; value); /* 添加 K-V */</span><br><span class="line"></span><br><span class="line">    void Delete(const Slice&amp; key);                  /* 删除 K-V */</span><br><span class="line"></span><br><span class="line">    void Append(const WriteBatch&amp; source);          /* Copy WriteBatch */</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /* Iterate 方法将会遍历 rep_ 中的 K-V，并根据 K-V 中的 Value Type 来决定</span><br><span class="line"></span><br><span class="line">     * 调用 handler-&gt;Put() 或 handler-&gt;Delete()，Handler 是一个抽象基类*/</span><br><span class="line"></span><br><span class="line">    Status Iterate(Handler* handler) const;         </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    friend class WriteBatchInternal;</span><br><span class="line"></span><br><span class="line">    std::string rep_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际的put操作是batch.Put(key, value); </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/* 将 User Key、User Value 以及 Value Type 追加到 rep_ 中 */</span><br><span class="line"></span><br><span class="line">void WriteBatch::Put(const Slice&amp; key, const Slice&amp; value) &#123;</span><br><span class="line"></span><br><span class="line">  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);</span><br><span class="line"></span><br><span class="line">  rep_.push_back(static_cast&lt;char&gt;(kTypeValue));</span><br><span class="line"></span><br><span class="line">  PutLengthPrefixedSlice(&amp;rep_, key);</span><br><span class="line"></span><br><span class="line">  PutLengthPrefixedSlice(&amp;rep_, value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void WriteBatchInternal::SetCount(WriteBatch* b, int n) &#123;</span><br><span class="line"></span><br><span class="line">  EncodeFixed32(&amp;b-&gt;rep_[8], n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* PutLengthPrefixedSlice 只针对于 uint32_t，将 value.size 进行编码，并放在 dst 的尾部</span><br><span class="line"></span><br><span class="line"> * 该方法将会在 WriteBatch::Put() 方法中被调用 */</span><br><span class="line"></span><br><span class="line">void PutLengthPrefixedSlice(std::string* dst, const Slice&amp; value) &#123;</span><br><span class="line"></span><br><span class="line">  PutVarint32(dst, value.size());</span><br><span class="line"></span><br><span class="line">  dst-&gt;append(value.data(), value.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>WriteBatch::Put</code> 只是简单地将 User Key、User Value 以及 Value Type 进行打包，得到一个打包后的“数组”，其内存布局如下图所示: </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=OTBkY2I1MTAwYzk5NDE1YmZkYjhlMDU2YTEzNjJhNWFfNTFrVXZqR3E2Um9XektXcFBSTkVWZmI0UHJIOFdFODBfVG9rZW46Ym94Y25tSFU4SVZyT1BUNXc3SmRVWmtpNTRkXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>需要注意的是在 <code>rep_</code> 的起始位置存在 12 字节的预留位，用于填充这些 K-V 的起始 Sequence Number 以及 Count 计数。 </p>
<p>将多个 K-V 打包完成以后，将会调用 <code>DBImpl::Write()</code> 方法，正式进入 leveldb 的写入流程。 </p>
<h2 id="写入逻辑"><a href="#写入逻辑" class="headerlink" title="写入逻辑"></a>写入逻辑</h2><p>在将数据写入预写日志文件之前，需要循环确认leveldb的状态，包括： </p>
<ul>
<li>MemTable是否达到了最大容量 <ul>
<li>达到并且此时Immutable Memtable没有flush到磁盘，则阻塞leveldb的写入线程，直到完成flush操作。</li>
</ul>
</li>
<li>Level0的文件数量是否达到阈值</li>
</ul>
<p>上述操作是在MakeRoomForWrite中进行的。 </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJhNTAwMmI4ZDhiOTZiMjc3NDk2MGM2ZDVlYTM2M2RfUmpvQ21XYXJyanpOUE5TUDY5dnA5Y1NTV0oxTGJ5UWJfVG9rZW46Ym94Y25sQUJwcW5sYVJYbE9Ua3h0TERhenNnXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct DBImpl::Writer &#123;</span><br><span class="line"></span><br><span class="line">  Status status; // 写入结果</span><br><span class="line"></span><br><span class="line">  WriteBatch* batch; </span><br><span class="line"></span><br><span class="line">  bool sync; //本次写入对应的log是否立刻刷盘</span><br><span class="line"></span><br><span class="line">  bool done; //本次写入是否完成</span><br><span class="line"></span><br><span class="line">  port::CondVar cv; //条件锁，会被之前的写入线程唤醒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  explicit Writer(port::Mutex* mu) : cv(mu) &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>进去先获取锁，保证一个时间只有一个线程能够写入，<strong>然后将自己放入writers队列中，被阻塞直到自己的任务已经完成了或者现在队头已经是自己了。</strong> </li>
<li>队列消费时候是使用<code>BuildBatchGroup</code>来进行的，一次会从<code>writers</code>取出多个Write的数据来写入到KV中，所以即使自己没有执行自己的Writer也可能自己的Wrtier已经被别的线程执行完毕。</li>
</ol>
<ul>
<li>如果当前Writer已经被其他线程执行，返回。</li>
</ul>
<ol>
<li>Iterator取出Queue中的一个or多个Writer，并更新sequence number。 </li>
<li><strong>在实际写入WAL的时候，释放锁，</strong>因为现在queue的front还是自己，所以即使其他的线程向queue中push，也会被w.cv.Wait()阻塞。从而保证现在只有当前Writer在写。 </li>
<li>写入成功之后，在依次从Queue中取出Writer直到<code>if (ready == last_writer) break;</code>每次取出数据时候signal一下，让对应线程退出去。 </li>
<li>如果队列不为空，则唤醒队头元素。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br></pre></td><td class="code"><pre><span class="line">/* leveldb Write 实现，过程如下:</span><br><span class="line"></span><br><span class="line"> * 1. 循环检测 leveldb 的状态，包括 Level-0 的文件个数、MemTable 是否已满等信息，将在</span><br><span class="line"></span><br><span class="line"> *    MakeRoomForWrite() 调用中完成，该函数可能会被阻塞。</span><br><span class="line"></span><br><span class="line"> * 2. 设置 WriteBatch 的 Sequence Number，并写入 WAL</span><br><span class="line"></span><br><span class="line"> * 3. 写入 MemTable</span><br><span class="line"></span><br><span class="line"> * 4. 更新 Sequence Number</span><br><span class="line"></span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* my_batch) &#123;</span><br><span class="line"></span><br><span class="line">  Writer w(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  //先加锁，保证只有一个线程能写入，在开始写log和memtable的时候会释放</span><br><span class="line"></span><br><span class="line">  MutexLock l(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">  //加入等待队列中排队</span><br><span class="line"></span><br><span class="line">  writers_.push_back(&amp;w);</span><br><span class="line"></span><br><span class="line">  //如果此次写入没有被执行且不处于队列头部，则等待之前的写入完成</span><br><span class="line"></span><br><span class="line">  while (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line"></span><br><span class="line">    w.cv.Wait();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //如果此次写入已经执行了，则直接返回</span><br><span class="line"></span><br><span class="line">  //其他写入请求在写入时可能会将队列中的写入请求一起取出合并写入DB中</span><br><span class="line"></span><br><span class="line">  if (w.done) &#123;</span><br><span class="line"></span><br><span class="line">    return w.status;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //写入前的检查，memtable、wal日志、compaction等，可能会阻塞住此次写入</span><br><span class="line"></span><br><span class="line">  /* 确定写入策略，写入策略与 Level-0 的 SSTable 数量有关，具体的枚举值定义在 dbformat.h 中</span><br><span class="line"></span><br><span class="line">   *</span><br><span class="line"></span><br><span class="line">   * - 当 Level-0 的文件数量达到阈值 kL0_SlowdownWritesTrigger = 8 时，会延迟 1ms 写入，</span><br><span class="line"></span><br><span class="line">   *   等待 Level-0 向下 Compaction。本质上就是 sleep 1 毫秒。</span><br><span class="line"></span><br><span class="line">   * - 当 Level-0 的文件数量达到阈值 kL0_StopWritesTrigger = 12 时，将会停止写入，等待</span><br><span class="line"></span><br><span class="line">   *   Level-0 向下 Compaction */</span><br><span class="line"></span><br><span class="line">  Status status = MakeRoomForWrite(my_batch == NULL);</span><br><span class="line"></span><br><span class="line">  uint64_t last_sequence = versions_-&gt;LastSequence();</span><br><span class="line"></span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line"></span><br><span class="line">  if (status.ok() &amp;&amp; my_batch != NULL) &#123;</span><br><span class="line"></span><br><span class="line">    //合并队列里的多个写入</span><br><span class="line"></span><br><span class="line">    WriteBatch* updates = BuildBatchGroup(&amp;last_writer);</span><br><span class="line"></span><br><span class="line">    WriteBatchInternal::SetSequence(updates, last_sequence + 1);</span><br><span class="line"></span><br><span class="line">    last_sequence += WriteBatchInternal::Count(updates);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 写入wal日志和memtable，写入前可以先释放锁，让后续write请求进入队列中排队，</span><br><span class="line"></span><br><span class="line">    //这样也能保证写入时互斥的，因为此时已经确定是只有w来负责写入 ，这样可以减小互斥时间</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</span><br><span class="line"></span><br><span class="line">      bool sync_error = false;</span><br><span class="line"></span><br><span class="line">      if (status.ok() &amp;&amp; options.sync) &#123;</span><br><span class="line"></span><br><span class="line">        status = logfile_-&gt;Sync();</span><br><span class="line"></span><br><span class="line">        if (!status.ok()) &#123;</span><br><span class="line"></span><br><span class="line">          sync_error = true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (status.ok()) &#123;</span><br><span class="line"></span><br><span class="line">        status = WriteBatchInternal::InsertInto(updates, mem_);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //更新versions时需要加锁，确保last_sequence正确修改</span><br><span class="line"></span><br><span class="line">      mutex_.Lock();</span><br><span class="line"></span><br><span class="line">      if (sync_error) &#123;</span><br><span class="line"></span><br><span class="line">        //wal日志sync失败</span><br><span class="line"></span><br><span class="line">        RecordBackgroundError(status);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (updates == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //修改合并写入请求的状态</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line"></span><br><span class="line">    Writer* ready = writers_.front();</span><br><span class="line"></span><br><span class="line">    writers_.pop_front();</span><br><span class="line"></span><br><span class="line">    if (ready != &amp;w) &#123;</span><br><span class="line"></span><br><span class="line">      ready-&gt;status = status;</span><br><span class="line"></span><br><span class="line">      ready-&gt;done = true;</span><br><span class="line"></span><br><span class="line">      ready-&gt;cv.Signal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ready == last_writer) break;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 唤醒队列头部的请求</span><br><span class="line"></span><br><span class="line">  if (!writers_.empty()) &#123;</span><br><span class="line"></span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line"> * 1. 如果当前队头的数据比较小，则maxsize= 当前size+(128 &lt;&lt; 10);</span><br><span class="line"></span><br><span class="line"> *  如果当前size比较大，则maxSize = 1 &lt;&lt; 20;</span><br><span class="line"></span><br><span class="line"> * 2. last_Wrtier记录的是已经iterator的最后一个Writer。</span><br><span class="line"></span><br><span class="line"> * 3. 如果当前队头是not fsync但是其后的是fsync则break（即使没有达到maxsize）</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) &#123;</span><br><span class="line"></span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line"></span><br><span class="line">  Writer* first = writers_.front();</span><br><span class="line"></span><br><span class="line">  WriteBatch* result = first-&gt;batch;</span><br><span class="line"></span><br><span class="line">  assert(result != nullptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  size_t size = WriteBatchInternal::ByteSize(first-&gt;batch);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Allow the group to grow up to a maximum size, but if the</span><br><span class="line"></span><br><span class="line">  // original write is small, limit the growth so we do not slow</span><br><span class="line"></span><br><span class="line">  // down the small write too much.</span><br><span class="line"></span><br><span class="line">  size_t max_size = 1 &lt;&lt; 20;</span><br><span class="line"></span><br><span class="line">  if (size &lt;= (128 &lt;&lt; 10)) &#123; // 128&lt;&lt;10 = 1&lt;&lt;7&lt;&lt;10 = 1&lt;&lt;17</span><br><span class="line"></span><br><span class="line">    max_size = size + (128 &lt;&lt; 10);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *last_writer = first;</span><br><span class="line"></span><br><span class="line">  std::deque&lt;Writer*&gt;::iterator iter = writers_.begin();</span><br><span class="line"></span><br><span class="line">  ++iter;  // Advance past &quot;first&quot;</span><br><span class="line"></span><br><span class="line">  for (; iter != writers_.end(); ++iter) &#123;</span><br><span class="line"></span><br><span class="line">    Writer* w = *iter;</span><br><span class="line"></span><br><span class="line">    if (w-&gt;sync &amp;&amp; !first-&gt;sync) &#123;</span><br><span class="line"></span><br><span class="line">      // Do not include a sync write into a batch handled by a non-sync write.</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (w-&gt;batch != nullptr) &#123;</span><br><span class="line"></span><br><span class="line">      size += WriteBatchInternal::ByteSize(w-&gt;batch);</span><br><span class="line"></span><br><span class="line">      if (size &gt; max_size) &#123;</span><br><span class="line"></span><br><span class="line">        // Do not make batch too big</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // Append to *result</span><br><span class="line"></span><br><span class="line">      if (result == first-&gt;batch) &#123;</span><br><span class="line"></span><br><span class="line">        // Switch to temporary batch instead of disturbing caller&#x27;s batch</span><br><span class="line"></span><br><span class="line">        result = tmp_batch_;</span><br><span class="line"></span><br><span class="line">        assert(WriteBatchInternal::Count(result) == 0);</span><br><span class="line"></span><br><span class="line">        WriteBatchInternal::Append(result, first-&gt;batch);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      WriteBatchInternal::Append(result, w-&gt;batch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *last_writer = w;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// REQUIRES: mutex_ is held</span><br><span class="line"></span><br><span class="line">// REQUIRES: this thread is currently at the front of the writer queue</span><br><span class="line"></span><br><span class="line">Status DBImpl::MakeRoomForWrite(bool force) &#123;</span><br><span class="line"></span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line"></span><br><span class="line">  bool allow_delay = !force;</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line"></span><br><span class="line">    if (!bg_error_.ok()) &#123;</span><br><span class="line"></span><br><span class="line">      // Yield previous error</span><br><span class="line"></span><br><span class="line">      s = bg_error_;</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    &#125; else if (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(0) &gt;=</span><br><span class="line"></span><br><span class="line">                                  config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      /* 当 Level-0 的文件数达到阈值 kL0_SlowdownWritesTrigger = 8 时，延迟 1 毫秒写入 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // We are getting close to hitting a hard limit on the number of</span><br><span class="line"></span><br><span class="line">      // L0 files.  Rather than delaying a single write by several</span><br><span class="line"></span><br><span class="line">      // seconds when we hit the hard limit, start delaying each</span><br><span class="line"></span><br><span class="line">      // individual write by 1ms to reduce latency variance.  Also,</span><br><span class="line"></span><br><span class="line">      // this delay hands over some CPU to the compaction thread in</span><br><span class="line"></span><br><span class="line">      // case it is sharing the same core as the writer.</span><br><span class="line"></span><br><span class="line">      mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">      /* Microseconds 和 Milliseconds 傻傻分不清，这里将睡眠 1 毫秒 */</span><br><span class="line"></span><br><span class="line">      env_-&gt;SleepForMicroseconds(1000);</span><br><span class="line"></span><br><span class="line">      allow_delay = false;  // Do not delay a single write more than once</span><br><span class="line"></span><br><span class="line">      mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    &#125; else if (!force &amp;&amp;</span><br><span class="line"></span><br><span class="line">               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line"></span><br><span class="line">      // There is room in current memtable</span><br><span class="line"></span><br><span class="line">      /* 当前 MemTable 未满(小于等于 4MB)，可以进行写入 */</span><br><span class="line"></span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    &#125; else if (imm_ != nullptr) &#123;</span><br><span class="line"></span><br><span class="line">      // We have filled up the current memtable, but the previous</span><br><span class="line"></span><br><span class="line">      // one is still being compacted, so we wait.</span><br><span class="line"></span><br><span class="line">      /* 等待 Immutable MemTable 刷盘 */</span><br><span class="line"></span><br><span class="line">      Log(options_.info_log, &quot;Current memtable full; waiting...\n&quot;);</span><br><span class="line"></span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">    &#125; else if (versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line"></span><br><span class="line">      // There are too many level-0 files.</span><br><span class="line"></span><br><span class="line">      /* 当 Level-0 的文件数达到阈值 kL0_StopWritesTrigger = 12 时，将停止写入 */</span><br><span class="line"></span><br><span class="line">      Log(options_.info_log, &quot;Too many L0 files; waiting...\n&quot;);</span><br><span class="line"></span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // Attempt to switch to a new memtable and trigger compaction of old</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      /* 此时表示 Immutable Memory Table 不存在，并且 Memory Table 已经写满了。</span><br><span class="line"></span><br><span class="line">       * 那么我们需要将 MemTable 转变成 Immutable MemTable，并主动触发 Compaction，</span><br><span class="line"></span><br><span class="line">       * 此时的 Compaction 主要是 Minor Compaction */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      assert(versions_-&gt;PrevLogNumber() == 0);</span><br><span class="line"></span><br><span class="line">      uint64_t new_log_number = versions_-&gt;NewFileNumber();</span><br><span class="line"></span><br><span class="line">      WritableFile* lfile = nullptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      /* 生成新的预写日志文件 */</span><br><span class="line"></span><br><span class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line"></span><br><span class="line">      if (!s.ok()) &#123;</span><br><span class="line"></span><br><span class="line">        // Avoid chewing through file number space in a tight loop.</span><br><span class="line"></span><br><span class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line"></span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      delete log_;</span><br><span class="line"></span><br><span class="line">      delete logfile_;</span><br><span class="line"></span><br><span class="line">      logfile_ = lfile;</span><br><span class="line"></span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line"></span><br><span class="line">      log_ = new log::Writer(lfile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      /* 将 MemTable 转换成 Immutable MemTable */</span><br><span class="line"></span><br><span class="line">      imm_ = mem_;</span><br><span class="line"></span><br><span class="line">      has_imm_.store(true, std::memory_order_release);</span><br><span class="line"></span><br><span class="line">      /* 初始化一个新的 MemTable */</span><br><span class="line"></span><br><span class="line">      mem_ = new MemTable(internal_comparator_);</span><br><span class="line"></span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">      force = false;  // Do not force another compaction if have room</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      /* 主动触发 Compaction */</span><br><span class="line"></span><br><span class="line">      MaybeScheduleCompaction();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WAL格式（4MB、32KB）"><a href="#WAL格式（4MB、32KB）" class="headerlink" title="WAL格式（4MB、32KB）"></a>WAL格式（4MB、32KB）</h2><p>因为内存中的数据容易丢失，所以写入到WAL中。在将数据写入到WAL中之后再去处理核心逻辑可以防止数据丢失。 </p>
<p>LevelDB中的WAL没有采用MySQL中那样的循环写入方式，而是创建新的日志文件并删除旧有的日志文件实现的。 </p>
<p><strong>WAL默认4MB，分成了32KB大小的连续Block，每个Block会有多个连续的日志记录。</strong> </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGM4NjM3NTc1NTM5NTNlODFlNGJjYmNhMTcwMmEzMTlfUU5VU0swNlpGZ3NyU0lySkNJSVM4V0VPaUVqb0J4dlRfVG9rZW46Ym94Y25GSXdrcGVQdXViTkRzU2plbmJtOW1kXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">RecordType</span> &#123;</span><br><span class="line"></span><br><span class="line">  kZeroType = <span class="number">0</span>,        <span class="comment">/* 预留给预分配文件 */</span></span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,        <span class="comment">/* 当前 Record 包含完整的日志记录 */</span></span><br><span class="line"></span><br><span class="line">  kFirstType = <span class="number">2</span>,       <span class="comment">/* 当前 Record 包含日志记录的起始部分 */</span></span><br><span class="line"></span><br><span class="line">  kMiddleType = <span class="number">3</span>,      <span class="comment">/* 当前 Record 包含日志记录的中间部分 */</span></span><br><span class="line"></span><br><span class="line">  kLastType = <span class="number">4</span>         <span class="comment">/* 当前 Record 包含日志记录的结束部分 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果User key和User Value的数据超过32KB的时候，Record就可能出现跨Block存储，此时该日志记录就需要切分成多个LogRecord在多个Block中进行存储，RecordType 就是用来记录当前Record是切分后的哪一部分的。 </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=YzdmY2ViN2EyOWM5MzIyYzMwMTEwODJlZTZjZTRlNGNfdjBmcDNaWFpRaDduVGpsN3NlOWZBOGtRN3R4Mk04M09fVG9rZW46Ym94Y242ZGgweG5mRGQ3UzdPa29FS3VhV2RjXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<h2 id="WAL写入流程"><a href="#WAL写入流程" class="headerlink" title="WAL写入流程"></a>WAL写入流程</h2><p>与预写日志相关的类主要包括 3 个: <code>WritableFile</code>、<code>Writer</code> 以及 <code>PosixWritableFile</code>。其中 <code>WritableFile</code> 看名字就可以知道是一个 Interface，并且 <code>PosixWritableFile</code> 实现了该接口。而 <code>Writer</code> 则依赖于 <code>WritableFile</code>，它们之间的关系可见下图: </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgwYjc4Yjc4MDIwMGY4MGViOTk1OTc4MzgwNTVlZGJfWWxUOGowWWFFdktuTVllVVJXRVJheGF5TkNSeFhycXhfVG9rZW46Ym94Y250WkV6dTM3VFQ4bnRMOWd4YWdaeFJjXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>在写入WriteBatch的时候，先调用AddRecord将数据插入到WAL中。 </p>
<ol>
<li>传入AddRecord的Slice就是WriteBatch的rep_。 </li>
<li>然后初始化begin&#x3D;T，标识这是起始位置。End表示结束位置。 <ol>
<li>通过begin 和 end来确定RecordType。</li>
</ol>
</li>
<li>执行具体的写入操作。 <ol>
<li>判断当前Block剩余的空间leftover是否大于kHeaderSize（ <em>Header is checksum (4 bytes), length (2 bytes), type (1 byte).）</em> </li>
<li>如果不够7B则使用0填充leftover，从而向新的block写入。 </li>
<li><strong>Record Header 不能跨 Block 写入</strong>。 </li>
<li>计算block的剩余容量，以及和record还需要的容量进行比较，确定type <ol>
<li><code>end=T iff block剩余容量&gt;=当前record还需要的容量。</code></li>
</ol>
</li>
<li>写入日志，修改slice的指针值和left大小。</li>
</ol>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Status</span> <span class="title class_">Writer</span>::<span class="title class_">AddRecord</span>(<span class="keyword">const</span> <span class="title class_">Slice</span>&amp; slice) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取 WriteBatch 底层 rep_ 的数据 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> char* ptr = slice.<span class="title function_">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 还剩下多少字节需要写入，在写入过程中该值将减少 */</span></span><br><span class="line"></span><br><span class="line">  size_t left = slice.<span class="title function_">size</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line"></span><br><span class="line">  <span class="title class_">Status</span> s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 标志位，表示当前日志记录是否是第一次写入 */</span></span><br><span class="line"></span><br><span class="line">  bool begin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算当前 Block 剩余写入 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> int leftover = kBlockSize - block_offset_;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">assert</span>(leftover &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前 Block 不足以写入 Record Header 的话，需要使用新的 Block */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果还有剩余空间的话，用 0 进行补齐 */</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        dest_-&gt;<span class="title class_">Append</span>(<span class="title class_">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Block 写入偏移量清零，向新的 Block 中写入 */</span></span><br><span class="line"></span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算剩余写入容量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> size_t avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算片段长度 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> size_t fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title class_">RecordType</span> <span class="keyword">type</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> bool end = (left == fragment_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;   <span class="comment">/* 刚好装下 */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">type</span> = kFullType;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;   <span class="comment">/* 一个 Block 无法装下 */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">type</span> = kFirstType;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;     <span class="comment">/* 能装下上一份数据 */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">type</span> = kLastType;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;              <span class="comment">/* 其它的中间状态 */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">type</span> = kMiddleType;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 写入预写日志 */</span></span><br><span class="line"></span><br><span class="line">    s = <span class="title class_">EmitPhysicalRecord</span>(<span class="keyword">type</span>, ptr, fragment_length);</span><br><span class="line"></span><br><span class="line">    ptr += fragment_length;</span><br><span class="line"></span><br><span class="line">    left -= fragment_length;</span><br><span class="line"></span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">while</span> (s.<span class="title function_">ok</span>() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmitPhysicalRecord()才是日志真正被写入的地址。 </p>
<p>在 <code>EmitPhysicalRecord()</code> 方法中，会计算数据的 CRC32、数据长度等信息，并调用 <code>WritableFile</code> 接口的 <code>Append()</code> 和 <code>Flush()</code> 方法将数据写入至内核缓冲区中，而是否进行 <code>fsync()</code> 取决于用户的配置，也就是 <code>Options.sync</code> 字段。 </p>
<h2 id="读取流程-TODO"><a href="#读取流程-TODO" class="headerlink" title="读取流程(TODO)"></a>读取流程(TODO)</h2><h2 id="预写日志清理"><a href="#预写日志清理" class="headerlink" title="预写日志清理"></a>预写日志清理</h2><p>预写日志的大小不可能无限制地增长，因此，要么采用后台线程定时清理，要么将清理逻辑分散在其它业务逻辑中，当触发了某一个条件时对其进行清理。leveldb 采用了后者的实现方式，即将预写日志的删除放在了关键节点中，由系统运行时进行触发。 </p>
<p>预写日志的清理由 <code>RemoveObsoleteFiles()</code> 方法进行，并且主要发生在两个部分，一个是在调用 <code>Open()</code> 方法打开 DB 时，leveldb 将会清理不再需要的文件，其中就包括了预写日志文件。另一个则是发生在 Compaction 时。 </p>
<p>当完成 Minor Compaction 之后，Immutable Mmetable 已经被持久化至硬盘中，那么此前的一些预写日志就可以被删除了，因为这部分数据不会在宕机时丢失。 </p>
<p>而在进行 Major Compaction 时，将会由后台线程完成 Compaction 的动作，因此可以借着这一异步任务来完成预写日志的清理，不必再开辟新的线程。 </p>
<p>最后需要注意的是，WAL 需要保留上一个预写日志，以防止意外发生。 </p>
<h1 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUxODUxNjI4M2MxMzk2Y2NlZDQ5ODU2MWEwYjAxZDFfcTRNUndDN1ZmNUc3SzV5blFxT2tkUGIzRFZKR0FQa2hfVG9rZW46Ym94Y240S1o1c0hTQjJIZ0dwTURTYlQ3T0lmXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>SStable主要由DataBlock&#x2F;MetaBlock&#x2F;MetaIndexBlock&#x2F;IndexBlock以及Footer组成。 </p>
<p>主要分为：用户数据、索引数据和元数据。 </p>
<ul>
<li>DataBlock存储的是排好序的UserKey以及UserValue。为了节省存储空间，使用的是<strong>前缀压缩</strong>。 </li>
<li>MetaBlock用来快速filter，确定某一个UserKey是否存在于当前的SSTable，默认布隆。 </li>
<li>MetaIndexBlock：指向MetaBlock的索引。 </li>
<li>IndexBlock：指向DataBlock的索引。 </li>
<li>Footer：包含了MetaIndexBlock和IndexBlock，指向了他们的起始地址和长度。</li>
</ul>
<h2 id="DataBlock（前缀压缩、重启点）"><a href="#DataBlock（前缀压缩、重启点）" class="headerlink" title="DataBlock（前缀压缩、重启点）"></a>DataBlock（前缀压缩、重启点）</h2><p>User Key 和 User Value 在 leveldb 中是未做分离处理的，也就是说<strong>每一对 Key-Value 都会按照一定的顺序存储到 Data Block 中</strong>，并且 Data Block 是从文件起始位置连续存储的。 </p>
<p>在一个 Data Block 中，可能会有多条数据记录，同时由于这些数据记录是有序存储的（默认为字典序），那么相邻的两条数据之间的 User Key 就有很大的可能性出现前缀重叠，如下图的 4 个 User Key，它们都具有相同的 “sma” 前缀: </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=NDQ3MTRlNzY2YjJmMmZiODAzYmI1ZWI4NjJkOWY2ZjdfMlRVUlFDY09DWVZ5QVVsSHVIZ2NmNDNyVUhNRWViZVNfVG9rZW46Ym94Y250WFZjS29PUHFqalZBTUZPR0FFVkhkXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>如此一来，leveldb 就可以对其进行前缀压缩处理了。对于有序的字符串而言，这么做能够节省非常多的存储空间，但是会<strong>对查询增加复杂度，也会影响查询效率。</strong> </p>
<p><strong>为了减轻对查询效率的影响，使用了Restart Point这个概念。</strong>其是每隔K个（<code>Options.block_restart_interval</code> 中，默认为 16）UserKey，不采用前缀压缩，而是直接存储整个User Key，在查找时候，现在Restart list中进行二分，然后再顺序扫描restart Point指向的数据。 </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ4Y2ZlNmRjN2I4MGQwMzUwODQ2YmQ5YjFlMGY4YzBfVURrbTl3UlhmMnFDOXRLSHJIZXdwQlphT3k5aTJ3QkVfVG9rZW46Ym94Y253cDIzanJtNGFZZnAzdEJxcnIwRFBoXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>DataBlock的构建是用BlockBuilder来完成的，类本身的定义是比较简单的。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class BlockBuilder &#123;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line"></span><br><span class="line">  explicit BlockBuilder(const Options* options);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  BlockBuilder(const BlockBuilder&amp;) = delete;</span><br><span class="line"></span><br><span class="line">  BlockBuilder&amp; operator=(const BlockBuilder&amp;) = delete;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 清空 */</span><br><span class="line"></span><br><span class="line">  void Reset();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 添加一个 Key-Value对 */</span><br><span class="line"></span><br><span class="line">  void Add(const Slice&amp; key, const Slice&amp; value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 完成 Block 的构建，压入重启点信息，并返回 buffer_，设置 finished_ 为 true */</span><br><span class="line"></span><br><span class="line">  Slice Finish();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 返回 Block 的预估大小 */</span><br><span class="line"></span><br><span class="line">  size_t CurrentSizeEstimate() const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 判断 buffer_ 是否为空 */</span><br><span class="line"></span><br><span class="line">  bool empty() const &#123; return buffer_.empty(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line"></span><br><span class="line">  const Options* options_;          /* Options 对象 */</span><br><span class="line"></span><br><span class="line">  std::string buffer_;              /* User Space 缓冲区 */</span><br><span class="line"></span><br><span class="line">  std::vector&lt;uint32_t&gt; restarts_;  /* Restart Points 数组 */</span><br><span class="line"></span><br><span class="line">  int counter_;                     /* Entry 计数器，用于重启点的计算 */</span><br><span class="line"></span><br><span class="line">  bool finished_;                   /* 是否已经调用了 Finish() 方法 */</span><br><span class="line"></span><br><span class="line">  std::string last_key_;            /* 最后添加的 Key */</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value)</code> 向 Block 中添加一个 User Key 与 User Value。 </p>
<ol>
<li>由于 Block 中的数据是有序存储的，那么此时该 User Key 必须要大于最后一个被添加到 Block 的 User Key，也就是 <code>last_key_</code>:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 last_key_ */</span></span><br><span class="line"></span><br><span class="line">Slice <span class="title function_">last_key_piece</span><span class="params">(last_key_)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(!finished_);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 要么 buffer_ 为空，要么 key 大于最后一个被添加到 Block 中的 Key */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(buffer_.empty()  <span class="comment">// No values yet?</span></span><br><span class="line"></span><br><span class="line">       || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>然后判断是否到达了重启点，没有达到则前缀压缩，到达了则记录完整的key。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">size_t shared = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 如果 counter_ &lt; block_restart_interval 的话，说明还没有到重启点，直接进行前缀压缩处理 */</span><br><span class="line"></span><br><span class="line">if (counter_ &lt; options_-&gt;block_restart_interval) &#123;</span><br><span class="line"></span><br><span class="line">  /* last_key_ 就像链表里面儿的 prev 指针一样，只需要计算当前 User Key 和 last_key_ 有多少重合度即可 */</span><br><span class="line"></span><br><span class="line">  const size_t min_length = std::min(last_key_piece.size(), key.size());</span><br><span class="line"></span><br><span class="line">  /* 统计前缀长度 */</span><br><span class="line"></span><br><span class="line">  while ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line"></span><br><span class="line">    shared++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  /* 此时 counter_ 必然等于 block_restart_interval，需要建立新的重启点</span><br><span class="line"></span><br><span class="line">      在构建index-block的时候，block_restart_interval被设置成了1。</span><br><span class="line"></span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  restarts_.push_back(buffer_.size());</span><br><span class="line"></span><br><span class="line">  counter_ = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>记录共享的前缀长度和非共享的长度，写入相关数据到buffer中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* 使用变长编码，将 &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; 写入 buffer_ */</span><br><span class="line"></span><br><span class="line">  PutVarint32(&amp;buffer_, shared);</span><br><span class="line"></span><br><span class="line">  PutVarint32(&amp;buffer_, non_shared);</span><br><span class="line"></span><br><span class="line">  PutVarint32(&amp;buffer_, value.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 将 User Key 非共享内容压入 buffer_ */</span><br><span class="line"></span><br><span class="line">  buffer_.append(key.data() + shared, non_shared);</span><br><span class="line"></span><br><span class="line">  /* 将完整的 Value 压入 buffer_ */</span><br><span class="line"></span><br><span class="line">  buffer_.append(value.data(), value.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 更新 last_key_ 为当前 User Key */</span><br><span class="line"></span><br><span class="line">  last_key_.resize(shared);</span><br><span class="line"></span><br><span class="line">  last_key_.append(key.data() + shared, non_shared);</span><br><span class="line"></span><br><span class="line">  assert(Slice(last_key_) == key);</span><br><span class="line"></span><br><span class="line">  counter_++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>当上层调用方使用 <code>BlockBuilder::Add()</code> 方法向 <code>buffer_</code> 中添加数据并达到一定量级以后，就可以调用 <code>Finish()</code> 方法将 <code>restarts_</code> 数组压入到 <code>buffer_</code> 中并返回完整的 Data Block 数据了:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Slice</span> <span class="title class_">BlockBuilder</span>::<span class="title class_">Finish</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 压入 restarts_ 数组中的全部内容至 buffer_ */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; restarts_.<span class="title function_">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">PutFixed32</span>(&amp;buffer_, restarts_[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 压入 Restart Points 数量 */</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">PutFixed32</span>(&amp;buffer_, restarts_.<span class="title function_">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置结束标志位 */</span></span><br><span class="line"></span><br><span class="line">    finished_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回完整的 Buffer 内容 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Slice</span>(buffer_);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MetaBlock"><a href="#MetaBlock" class="headerlink" title="MetaBlock"></a>MetaBlock</h2><p>Meta Block 存在的目的就是为了优化 SSTable 的读取性能，leveldb 使用 Bloom Filter 作为 Filter 的具体实现，用于快速判断某一个 User Key 是否存在于当前查找的 SSTable 中。若 Bloom Filter 给出了 <code>false</code> 的答案，那么待查找 User Key 必然不在当前 SSTable 中。若给出了 <code>true</code> 的答案，待查找 User Key 也不一定会在当前 SSTable 中，因为 Bloom Filter 存在“假阳性”的可能。 </p>
<h2 id="SStable索引"><a href="#SStable索引" class="headerlink" title="SStable索引"></a>SStable索引</h2><p>DataBlock和FilterBlock在文件中是连续存储的，并且大小不固定，所以需要建立索引，也就是MetaIndex Block和 Index Block。 </p>
<ol>
<li>MetaIndex Block</li>
</ol>
<p>存储Filter Block在整个SSTable中的索引信息，并且只有一行记录，只需要记录下使用的Filter Policy名称以及BlockHandle信息。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class BlockHandle &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    /* BlockHandle 的最大长度，即 20 字节 */</span><br><span class="line"></span><br><span class="line">    enum &#123; kMaxEncodedLength = 10 + 10 &#125;;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    uint64_t offset_;   /* 偏移量 */</span><br><span class="line"></span><br><span class="line">    uint64_t size_;     /* 数据大小 */</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BlockHandle只需要记录Filter Block的起始地址和大小即可。 </p>
<p>完整的FilterIndex Block格式如下： </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFmZjM5YjNkODhmMzRkOTkzNzIyZGQxMTMyNjZiYmNfQmFweFdTelVKZ2hCb1U2NlJUNExlS2dFQWxDV2NmRWRfVG9rZW46Ym94Y25RRjFwZ2R6QTdSR1ptcDE0cUFUeFVnXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<ul>
<li>MetaIndexBlock的起始地址是Filter+过滤器名字锁组成的常量字符串，默认使用布隆。 </li>
<li>然后BlockFilter之中的内容就是Filter Block的偏移量和大小。 </li>
<li>最后是统一的格式后缀：压缩类型（默认为 snappy 压缩）+crc</li>
</ul>
<h2 id="Index-Block"><a href="#Index-Block" class="headerlink" title="Index Block"></a>Index Block</h2><p>Index Block不仅仅需要记录每个DataBlock的起始位置和大小，还要<strong>额外记录每一个DataBlock的最大Key值（用于二分）</strong>，由<code>FindShortestSeparator</code>计算得到。 </p>
<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNkNDEwMjhlMTZkMzcxNmEwNjk0ZGEyYzhhNjVlYTdfbmdwZlh5NGR6Y0N6UUZEd1pkT3hYUjU2MkZNTWJwMG5fVG9rZW46Ym94Y25QOEhFZnlLaHRjV1lLcnhWWUVpeGd1XzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<p>在MaxKey之后就是正常的BlockHandle和压缩类型+CRC。 </p>
<h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><p>Footer大小固定，48B。 </p>
<ul>
<li>Data Block的每个Block都有Index Block进行索引；FilterBlock的每个都由MetaIndexBlock进行索引。 </li>
<li>由于IndexBlock和MetaIndexBlock的大小不固定，所以需要对IndexBlock和MetaIndexBlcok进行索引，并且这个索引文件的所处位置必须是固定的。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Footer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">public:</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 固定大小，48 字节，不足 48 字节时将使用 padding 填充 */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">enum</span> &#123; kEncodedLength = <span class="number">2</span> * <span class="attr">BlockHandle:</span>:kMaxEncodedLength + <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="attr">private:</span></span><br><span class="line"></span><br><span class="line">      BlockHandle metaindex_handle_;    <span class="comment">/* 索引 Metaindex Block */</span></span><br><span class="line"></span><br><span class="line">      BlockHandle index_handle_;        <span class="comment">/* 索引 Index Block */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=NGI0ZGJiYTBiNmU1YzM0N2M2MzM2Y2I3ZWRmNzQ4ZmZfdkswSGFFY2VuT2U2QzRCb3c5c3FRQmhmbkRBRlNXVU5fVG9rZW46Ym94Y25pbmJVU0kzR1lVSEkySTg4M1pRRkRmXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIzZjkwZWMxNzFjYzMzOTcxMDIzZjkzZjIxN2I3OGZfTGpERWgxZVg0SkRBb3VCMk9KRFpjYTVUemM4alpuSU1fVG9rZW46Ym94Y25tZkthencxZ1BEWlVYYk52dXhlZURlXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<h1 id="TableBuilder"><a href="#TableBuilder" class="headerlink" title="TableBuilder"></a>TableBuilder</h1><p>TableBuilder需要在完成对DataBlock、IndexBlock、FilterBlock、MetaIndexBlock的构建，得到一个完整的SSTable。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class LEVELDB_EXPORT TableBuilder &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    /* WritableFile 通常为 PosixWritableFile */</span><br><span class="line"></span><br><span class="line">    TableBuilder(const Options&amp; options, WritableFile* file);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /* 向 TableBuilder 中添加 Key-Value，这里的 Key 同样为 InternalKey */</span><br><span class="line"></span><br><span class="line">    void Add(const Slice&amp; key, const Slice&amp; value);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /* 将缓冲区中的数据 flush 到文件中，由 leveldb 内部调用 */</span><br><span class="line"></span><br><span class="line">    void Flush();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Status status() const;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /* 结束 Table 的构建 */</span><br><span class="line"></span><br><span class="line">    Status Finish();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /* 放弃 Table 的构建 */</span><br><span class="line"></span><br><span class="line">    void Abandon();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /* 一共添加了多少 Key-Value 对 */</span><br><span class="line"></span><br><span class="line">    uint64_t NumEntries() const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    bool ok() const &#123; return status().ok(); &#125;</span><br><span class="line"></span><br><span class="line">    /* 序列化需要写入的 Data Block */</span><br><span class="line"></span><br><span class="line">    void WriteBlock(BlockBuilder* block, BlockHandle* handle);</span><br><span class="line"></span><br><span class="line">    /* 将压缩后的数据写入文件中 */</span><br><span class="line"></span><br><span class="line">    void WriteRawBlock(const Slice&amp; data, CompressionType, BlockHandle* handle);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /* Rep 的作用就是隐藏具体实现 */</span><br><span class="line"></span><br><span class="line">    struct Rep;</span><br><span class="line"></span><br><span class="line">    Rep* rep_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 在 <code>TableBuilder</code> 中只有唯一的一个成员变量 <code>rep_</code>，其类型为 <code>Rep *</code>。<code>Rep_</code> 这个结构体的作用就是做了另一层的封装，能够让 <code>TableBuilder</code> 这个类更清爽一些: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct TableBuilder::Rep &#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    Options options;              /* Data Block Options */</span><br><span class="line"></span><br><span class="line">    Options index_block_options;  /* Index Block Options */</span><br><span class="line"></span><br><span class="line">    WritableFile* file;           /* 抽象类，决定了如何进行文件的写入，PosixWritableFile */</span><br><span class="line"></span><br><span class="line">    uint64_t offset;              /* Data Block 在 SSTable 中的文件偏移量 */</span><br><span class="line"></span><br><span class="line">    Status status;                /* 操作状态 */</span><br><span class="line"></span><br><span class="line">    BlockBuilder data_block;      /* 构建 Data Block 所需的 BlockBuilder */</span><br><span class="line"></span><br><span class="line">    BlockBuilder index_block;     /* 构建 Index Block 所需的 BlockBuilder */</span><br><span class="line"></span><br><span class="line">    std::string last_key;         /* 当前 Data Block 的最后一个写入 key */</span><br><span class="line"></span><br><span class="line">    int64_t num_entries;          /* 当前 Data Block 的写入数量 */</span><br><span class="line"></span><br><span class="line">    bool closed;                  /* 构建过程是否结束 */</span><br><span class="line"></span><br><span class="line">    FilterBlockBuilder* filter_block; /* 构建 Filter Block 所需的 BlockBuilder */</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    bool pending_index_entry;     /* pending_index_entry 用于 Add() 方法中 */</span><br><span class="line"></span><br><span class="line">    BlockHandle pending_handle;  // Handle to add to index block</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    std::string compressed_output;  /* 压缩之后的 Data Block */</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://rf6watz7fv.feishu.cn/space/api/box/stream/download/asynccode/?code=NWYwMTYxNzRlOGIxZjJlYzNlNjExZmIwNjQzMjhmYTNfU2FKczlNZTBtdDNHOFJhZUR0UmFHSzNKcG9Yems5MHBfVG9rZW46Ym94Y25VZlM0Wno5a3dvOEQ4TWVjNHpVdk1oXzE2NTEwNTI5OTM6MTY1MTA1NjU5M19WNA" alt="img"></p>
<ol>
<li><p>实际地向 Data Block 和 Filter Block 添加数据之前，需要进行基本的逻辑判断。 </p>
<ol>
<li>比如说当前 Build 过程是否结束，也就是是否已经调用了 <code>Finish()</code> 或者是 <code>Abandon()</code> 方法。 </li>
<li><strong>另一点就是需要保证当前添加的 Key 一定是大于</strong> <code>**last_key**</code> <strong>的，保证 Data Block 的有序性。</strong></li>
</ol>
</li>
<li><p>对 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pending_index_entry</span><br></pre></td></tr></table></figure>

<p> 进行判断，确定现在是否是一个新DataBlock的起始，如果是的话，</p>
<p>需要为上一个DataBlock构建IndexBlock。</p>
<ol>
<li>在新的DataBlock中构建上一个DataBlock的Index的目的是调用<code>FindShortestSeparator</code>来节省空间。</li>
</ol>
</li>
<li><p>调用实际的写入流程，写入到DataBlock和FilterBlock中。 </p>
</li>
<li><p>如果插入数据之后的DataBlock大小超过阈值，则调用Flush完成当前Blokc的构建。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">/* 此时的 key 仍然为 InternalKey，也就是 User Key + Sequence Number | Value Type */</span><br><span class="line"></span><br><span class="line">void TableBuilder::Add(const Slice&amp; key, const Slice&amp; value) &#123;</span><br><span class="line"></span><br><span class="line">  Rep* r = rep_;</span><br><span class="line"></span><br><span class="line">  assert(!r-&gt;closed);   /* 判断当前 Build 过程是否结束 */</span><br><span class="line"></span><br><span class="line">  if (!ok()) return;</span><br><span class="line"></span><br><span class="line">  if (r-&gt;num_entries &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">    /* 判断当前 key 是否大于 last_key */</span><br><span class="line"></span><br><span class="line">    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; 0);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 在构建下一个 Data Block 之前，将 Index Block 构建出来。</span><br><span class="line"></span><br><span class="line">   * pending_index_entry 是一个布尔型的标志位，用于表示是否到了生成 Index Block 的时机，</span><br><span class="line"></span><br><span class="line">   * 如果 pending_index_entry 为 true 的话，那么就去生成 Index Block，</span><br><span class="line"></span><br><span class="line">   * 否则继续构建 Data Block 和 Filter Block。</span><br><span class="line"></span><br><span class="line">   * */</span><br><span class="line"></span><br><span class="line">  if (r-&gt;pending_index_entry) &#123;</span><br><span class="line"></span><br><span class="line">    assert(r-&gt;data_block.empty());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line"></span><br><span class="line">     * 通过 last_key 和 当前 key 计算得到一个 X，使得 last_entry &lt;= X &lt; key</span><br><span class="line"></span><br><span class="line">     * 当 Add() 方法在写入下一个 Data Block 的第一个 Key-Value 对时，才会为上一个 Data Block 构建 Index Block，</span><br><span class="line"></span><br><span class="line">     * 这样做的目的是使用更短的Key来作为Index Block的MaxKey。</span><br><span class="line"></span><br><span class="line">     * 比如说上一个 Data Block 的数据为 [&quot;smart&quot;, &quot;split&quot;, &quot;slice&quot;, &quot;string&quot;]，</span><br><span class="line"></span><br><span class="line">     * 排序后得到 [&#x27;slice&#x27;, &#x27;smart&#x27;, &#x27;split&#x27;, &#x27;string&#x27;]。</span><br><span class="line"></span><br><span class="line">     * 因此，&quot;string&quot; 就是上一个 Data Block 的结束边界，如果说当前 Data Block 的起始边界为 &quot;sword&quot; 的话，</span><br><span class="line"></span><br><span class="line">     * 那么就可以使用 &quot;su&quot; 来作为上一个 Data Block 的 Index Block Key。</span><br><span class="line"></span><br><span class="line">     * 因为 &quot;su&quot; 大于 &quot;string&quot;，并且小于 &quot;sword&quot;。</span><br><span class="line"></span><br><span class="line">     * 这么做并不会影响搜索，同时节省了磁盘存储空间。</span><br><span class="line"></span><br><span class="line">     * */</span><br><span class="line"></span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line"></span><br><span class="line">    std::string handle_encoding;</span><br><span class="line"></span><br><span class="line">    // 构建BlockHandler</span><br><span class="line"></span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* 向 Index Block 中添加上一个 Data Block 的 Index</span><br><span class="line"></span><br><span class="line">     * [ MaxKey | BlockHandler| CompressType | CRC ]</span><br><span class="line"></span><br><span class="line">     * index_block.Add会有前缀压缩，但是没有关系，因为r-&gt;last_key就是当前key（无法压缩），</span><br><span class="line"></span><br><span class="line">     * 所以最终存储的还是完整的key</span><br><span class="line"></span><br><span class="line">     * */</span><br><span class="line"></span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* 上一个 Data Block 的 Index Block 已经写完，故更新 pending_index_entry 为 false */</span><br><span class="line"></span><br><span class="line">    r-&gt;pending_index_entry = false;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 若指定了 FilterPolicy，那么就会写入 Filter Block */</span><br><span class="line"></span><br><span class="line">  if (r-&gt;filter_block != nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 更新 last_key */</span><br><span class="line"></span><br><span class="line">  r-&gt;last_key.assign(key.data(), key.size());</span><br><span class="line"></span><br><span class="line">  /* 更新 Key-Value 写入数量 */</span><br><span class="line"></span><br><span class="line">  r-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">  /* 将数据添加至 Data Block 中 */</span><br><span class="line"></span><br><span class="line">  r-&gt;data_block.Add(key, value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* Data Block 的默认大小为 4KB */</span><br><span class="line"></span><br><span class="line">  const size_t estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line"></span><br><span class="line">  if (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line"></span><br><span class="line">    /* 结束当前 Block 的构建，Flush() 方法内部将会把 pending_index_entry 置为 True */</span><br><span class="line"></span><br><span class="line">    Flush();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Flush是在完成DataBlock构建之后调用的。再起内部使用Snappy进行压缩。 </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title class_">TableBuilder</span>::<span class="title function_ invoke__">Flush</span>() &#123;</span><br><span class="line"></span><br><span class="line">  Rep* r = rep_;</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">assert</span>(!r-&gt;closed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_ invoke__">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="keyword">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">assert</span>(!r-&gt;pending_index_entry);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 对 Data Block 进行压缩，并生成 Block Handle */</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_ invoke__">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_ invoke__">ok</span>()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 pending_index_entry 为 true，下一次写入 Data Block 时，需构建 Index Block */</span></span><br><span class="line"></span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将数据写入至内核缓冲区 */</span></span><br><span class="line"></span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;<span class="title function_ invoke__">Flush</span>();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建一个新的 Filter Block */</span></span><br><span class="line"></span><br><span class="line">    r-&gt;filter_block-&gt;<span class="title function_ invoke__">StartBlock</span>(r-&gt;offset);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finish </p>
<ol>
<li>首先调用 <code>TableBuilder::Flush()</code> 方法将最后一个 Data Block 写入，由于最后一个 Data Block 可能只有少数几个 Key-Value，无法自行触发 <code>Flush()</code> 方法的调用，因此需要主动地再次调用 </li>
<li>紧接着，将 Filter Block 写入。 </li>
<li>然后，写入 Metaindex Block，并添加 “filter.leveldb.BuiltinBloomFilter2” 到 Metaindex Block 中，以快速定位 Filter Data。 </li>
<li>最后，将 Index Block 和 Footer 写入即可，整个 SSTable 的构建过程也就结束。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">Status TableBuilder::Finish() &#123;</span><br><span class="line"></span><br><span class="line">  Rep* r = rep_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* 将最后一个 Data Block 写入，</span><br><span class="line"></span><br><span class="line">   * 因为最后一个DataBlock数据太少可以不足以触发Flush，所以需要显式触发一次</span><br><span class="line"></span><br><span class="line">   * */</span><br><span class="line"></span><br><span class="line">  Flush();</span><br><span class="line"></span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line"></span><br><span class="line">  r-&gt;closed = true;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Write filter block</span><br><span class="line"></span><br><span class="line">  // 在写完DataBlock之后再写FilterBlock</span><br><span class="line"></span><br><span class="line">  if (ok() &amp;&amp; r-&gt;filter_block != nullptr) &#123;</span><br><span class="line"></span><br><span class="line">    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line"></span><br><span class="line">                  &amp;filter_block_handle);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Write metaindex block</span><br><span class="line"></span><br><span class="line">  if (ok()) &#123;</span><br><span class="line"></span><br><span class="line">    BlockBuilder meta_index_block(&amp;r-&gt;options);</span><br><span class="line"></span><br><span class="line">    if (r-&gt;filter_block != nullptr) &#123;</span><br><span class="line"></span><br><span class="line">      // Add mapping from &quot;filter.Name&quot; to location of filter data</span><br><span class="line"></span><br><span class="line">      std::string key = &quot;filter.&quot;;</span><br><span class="line"></span><br><span class="line">      /* 若使用 Bloom Filter，key 的值为 filter.leveldb.BuiltinBloomFilter2 */</span><br><span class="line"></span><br><span class="line">      key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line"></span><br><span class="line">      std::string handle_encoding;</span><br><span class="line"></span><br><span class="line">      filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line"></span><br><span class="line">      meta_index_block.Add(key, handle_encoding);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // TODO(postrelease): Add stats and other meta blocks</span><br><span class="line"></span><br><span class="line">    /* 写入 Metaindex Block */</span><br><span class="line"></span><br><span class="line">    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Write index block</span><br><span class="line"></span><br><span class="line">  if (ok()) &#123;</span><br><span class="line"></span><br><span class="line">    if (r-&gt;pending_index_entry) &#123;</span><br><span class="line"></span><br><span class="line">      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line"></span><br><span class="line">      std::string handle_encoding;</span><br><span class="line"></span><br><span class="line">      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line"></span><br><span class="line">      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line"></span><br><span class="line">      r-&gt;pending_index_entry = false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Write footer</span><br><span class="line"></span><br><span class="line">  if (ok()) &#123;</span><br><span class="line"></span><br><span class="line">    Footer footer;</span><br><span class="line"></span><br><span class="line">    footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line"></span><br><span class="line">    footer.set_index_handle(index_block_handle);</span><br><span class="line"></span><br><span class="line">    std::string footer_encoding;</span><br><span class="line"></span><br><span class="line">    footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line"></span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line"></span><br><span class="line">    if (r-&gt;status.ok()) &#123;</span><br><span class="line"></span><br><span class="line">      r-&gt;offset += footer_encoding.size();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return r-&gt;status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/27/test-my-site/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/27/test-my-site/" class="post-title-link" itemprop="url">test_my_site</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-27 13:53:26" itemprop="dateCreated datePublished" datetime="2022-04-27T13:53:26+08:00">2022-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/27/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/27/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-27 13:51:35" itemprop="dateCreated datePublished" datetime="2022-04-27T13:51:35+08:00">2022-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
